<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="花有重开日，人无再少年">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding Poet">
<meta property="og:url" content="https://www.yoursite.com/index.html">
<meta property="og:site_name" content="Coding Poet">
<meta property="og:description" content="花有重开日，人无再少年">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="一清">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="JavaWeb">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="SpringMVC">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Mybatis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Coding Poet</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Coding Poet</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">Java 基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-05 12:36:54" itemprop="dateCreated datePublished" datetime="2019-12-05T12:36:54+08:00">2019-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 18:04:10" itemprop="dateModified" datetime="2020-04-10T18:04:10+08:00">2020-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="工具">工具</h1>
<h2 id="jdk">JDK</h2>
<p>JDK是Java开发工具包，其中包含<code>javac</code>与<code>java</code>两个程序，使用Java编程需要JDK。</p>
<h2 id="java编译运行">Java编译运行</h2>
<p>Java程序的编译运行是跨平台（指操作系统）的，主要归功于JVM，在Java程序的编译运行分为三步（<strong>编写、编译、运行。</strong>可直接使用命令行操作）：</p>
<ol type="1">
<li>编写源代码</li>
<li><code>.java</code>文件（源代码）通过 <code>javac.exe</code> 程序（编译器）编译成.class文件</li>
<li><code>.class</code>文件（又称字节码文件）通过 <code>java.exe</code> （解释器）转换成机器码，原理是放入对应平台的Java虚拟机（JVM）内转化为计算机可运行二进制机器码</li>
</ol>
<h2 id="jre">JRE</h2>
<p>JRE是Java运行环境，其中包含了JVM，由上步骤可知，想要运行Java程序，必须要有JRE。在安装JDK时，JDK中已经自带了JRE，所以不需要单独安装JRE</p>
<h2 id="为什么要配置环境变量">为什么要配置环境变量</h2>
<p>当你在命令行中使用 <code>javac</code> 或 <code>java</code> 时，需要先进入到jdk的安装目录中的 <code>bin</code> 文件目录下，才能运行Java命令，但是在命令行中运行记事本时，你只并不需要找到记事本的安装目录，直接输入notepad命令即可，<strong>这是因为计算机知道去哪里找记事本的目录，但是不知道去哪找Java的目录</strong>，为了能在命令行窗口中，直接运行Java，去掉繁琐的输目录的过程，所以我们需要在环境变量中添加路径。（即配置环境变量）</p>
<ol type="1">
<li>首先在系统变量栏添加一个 <code>JAVA_HOME</code> 来代替 <code>bin</code> 目录之前的一长串目录。</li>
<li>然后再在系统变量栏里找到 <code>Path</code> ，编辑一条<code>%JAVA_HOME%\bin</code>，<code>%JAVA_HOME%</code>就是代替了 <code>bin</code> 之前的一长串目录而已。</li>
<li>这样我们就把Java的路径添加到了环境变量中，计算机在收到Java指令的时候就知道去Java的目录下去寻找Java程序了。</li>
</ol>
<h1 id="基础概念">基础概念</h1>
<h2 id="关键字">关键字</h2>
<p>完全小写的字母。 在增强版的记事本（notepad++）或者其他IDE当中有特殊颜色。</p>
<h2 id="标识符">标识符</h2>
<p>类、方法、变量的名称，自己取的那种，但是</p>
<p><strong>要求：</strong> - 英文字母（区分大小写）、数字、<code>$</code>（不推荐，因为后面学到的内部类的class文件命名方式包含了此符号，见 <strong>23 内部类</strong>）和<code>_</code> - 不能以数字开头 - 不能是关键字</p>
<p><strong>建议：</strong> - 类名：大驼峰式 - 变量名：小驼峰式 - 方法名：小驼峰式</p>
<h2 id="常量">常量</h2>
<p>程序运行期间固定不变的量</p>
<p><strong>常量的分类：</strong> 1. 字符串常量：凡是用双引号引起来的部分，叫做字符串常量。 2. 整数常量：直接写上的数字，没有小数点。 3. 浮点数常量：直接写上的数字，有小数点。 4. 字符常量：凡是用单引号引起来的单个字符。叫做字符常量。（Java中 一个中文也是一个字符）<strong>两个单引号中间必须有且仅有一个字符，没有不行；有两个也不行。</strong> 5. 布尔常量：true、false 6. 空常量：null 代表没有任何数据 <strong>不能直接用来打印输出</strong></p>
<p>上述记录于2019.10.12</p>
<h2 id="变量">变量</h2>
<p>与常量相反。程序运行期间，内容可以发生改变的量。<strong>注意：变量赋值时，右侧数值范围不能超过左侧的数据范围 ，long与float赋值带后缀L与F</strong></p>
<p><strong>注意事项：</strong> 1. 如果创建多个变量，那么变量之间的名称不可以重复 2. 对于 <code>float</code> 和 <code>long</code> 类型来说，字母后缀F和L不要丢掉 3. 如果使用 <code>byte</code> 或者 <code>short</code> 类型的变量，右侧的数据值，不能超过左侧类型的范围 4. 没有进行赋值的变量不能直接使用，一定要赋值之后才能使用 5. 变量的使用不能超过作用域的范围。<strong>作用域：</strong> 从定义变量的一行开始，一直到直接所属的大括号结束为止 6. 可以通过一个语句来创建多个变量，但是一般情况下不推荐。</p>
<h1 id="数据类型">数据类型</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<p><strong>四类八种：</strong> - 整数型 <code>byte short int long</code> - 浮点型 <code>float double</code> 但是浮点数往往会有精度损失。所以在定义货币的时候，没有1.11元的说法，往往都是111分。<strong>详情请看《计算机组成原理》中存储浮点数的底层原理 </strong> - 字符型 <code>char</code> - 布尔型 <code>boolean</code></p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>关键字</th>
<th>内存占用</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>字节型</td>
<td>byte</td>
<td>1个字节（8位）</td>
<td>-128~127 ($ -2<sup>72</sup>7-1 $)</td>
</tr>
<tr class="even">
<td>短整型</td>
<td>short</td>
<td>2个字节</td>
<td>-32768~32767</td>
</tr>
<tr class="odd">
<td>整型</td>
<td>int(默认)</td>
<td>4个字节</td>
<td>$ -2<sup>{31}2</sup>{31}-1$（大约21个亿）</td>
</tr>
<tr class="even">
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td>$ -2<sup>{63}2</sup>{63}-1$</td>
</tr>
<tr class="odd">
<td>单精度浮点数</td>
<td>float</td>
<td>4个字节</td>
<td>1.4013E-45~3.4028E+38</td>
</tr>
<tr class="even">
<td>双精度浮点数</td>
<td>double(默认)</td>
<td>8个字节</td>
<td>4.9E-324~1.7977E+308</td>
</tr>
<tr class="odd">
<td>字符型</td>
<td>char</td>
<td>2个字节</td>
<td>0-65535</td>
</tr>
<tr class="even">
<td>布尔类型</td>
<td>boolean</td>
<td>1个字节</td>
<td>true false</td>
</tr>
</tbody>
</table>
<p><strong>注意事项：</strong> 1. 字符串不是基本类型，而是引用类型 2. 浮点型可能只是一个近似值，并非精确的值 3. 数据范围与字节数不一定相关， <code>float</code>（4字节）数据范围比 <code>long</code>（8字节）更加广泛。 4. 浮点数当中默认类型是 <code>double</code> 。如果一定要用 <code>float</code> ，需要加上一个后缀 <strong>F</strong>。如果是整数，默认为 <code>int</code> 类型，如果一定要用 <code>long</code> ，需要加上一个后缀 <strong>L</strong>。<strong>F L 大小写都可以，推荐大写</strong></p>
<h2 id="引用数据类型">引用数据类型</h2>
<p>不是基本数据类型 就是 引用数据类型 只有这两种。比如后面要介绍的字符串、数组、类、接口、Lambda等</p>
<h2 id="数据类型转换">数据类型转换</h2>
<p>当数据类型不一样时，将会发生数据类型转换</p>
<p><strong>一句话概括：</strong> 对于一行赋值语句<code>某个变量 =  某个变量/常量</code> 首先如果右边是常量，判断常量的值是否超过左边的类型对应的数值范围，若超过了，直接报错！ 然后判断左右两边类型的数值范围大小，若由小到大（右边小，左边大），可自动转。否则，需要强转！</p>
<ul>
<li>自动类型转换（隐式）</li>
</ul>
<ol type="1">
<li>特点：代码不需要进行特殊处理，自动完成</li>
<li>规则：<strong>数据范围从小到大,与字节数不一定相关</strong> 数据范围规则： <strong>byte、short、char --&gt; int --&gt; long --&gt; float --&gt; double</strong></li>
</ol>
<ul>
<li>强制类型转换（显式）</li>
</ul>
<ol type="1">
<li>特点：代码需要进行特殊的格式处理，不能自动完成。</li>
<li>格式： <code>范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据</code></li>
</ol>
<p><strong>注意事项：</strong> 1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 2. <code>byte/short/char</code> 这三种类型都可以发生数学运算。 3. <code>byte/short/char</code> 在运算的时候，都会被首先提升为int类型，然后再计算。<strong>4.2和4.6的代码块都有用到</strong> 4. <code>boolean</code>类型不能发生任何数据类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01DataType</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="number">1024</span>); <span class="comment">// 这就是一个整数，默认就是int类型</span></span><br><span class="line">		System.out.println(<span class="number">3.14</span>); <span class="comment">// 这就是一个浮点数，默认就是double类型</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 左边是long类型，右边是默认的int类型，左右不一样</span></span><br><span class="line">		<span class="comment">// int --&gt; long long的数据范围比较大，符合了数据范围从小到大的要求</span></span><br><span class="line">		<span class="comment">// 这一行代码发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">long</span> num1 = <span class="number">100</span>;</span><br><span class="line">		System.ou.println(num1); <span class="comment">//100</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//左边是double类型，右边是float类型，左右不一样</span></span><br><span class="line">		<span class="comment">//float --&gt; double，符合数据从小到大的规则</span></span><br><span class="line">		<span class="comment">// 也发生了自动类型转换</span></span><br><span class="line">		<span class="keyword">double</span> num2 = <span class="number">2.5F</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">//2.5</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//左边是float类型，右边是long类型</span></span><br><span class="line">		<span class="comment">//long --&gt; float 范围float跟更大。符合从小到大的规则</span></span><br><span class="line">        <span class="comment">// 自动类型转换</span></span><br><span class="line">		<span class="keyword">float</span> num3 = <span class="number">30L</span>；</span><br><span class="line">		System.out.println(num3)； <span class="comment">//30.0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02DataType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//左边是int类型，右边是long类型，不一样</span></span><br><span class="line">		<span class="comment">//long --&gt; int, 不是从小到大</span></span><br><span class="line">		<span class="comment">//不能自动类型转换 进行强制转换</span></span><br><span class="line">		<span class="keyword">int</span> num = (<span class="keyword">int</span>)<span class="number">100L</span>;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// long强制转换成int类型 数据溢出</span></span><br><span class="line">		<span class="keyword">int</span> num2 = (<span class="keyword">int</span>)<span class="number">6000000000L</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">//1705032704</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// double --&gt; int，强制类型转换 精度损失</span></span><br><span class="line">		<span class="keyword">int</span> num3 = (<span class="keyword">int</span>)<span class="number">3.99</span>;</span><br><span class="line">		System.out.println(num3); <span class="comment">//3 并不是四舍五入，所有小数位都会被舍弃</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> zifu1 = <span class="string">'A'</span>;</span><br><span class="line">		System.out.println(zifu1 + <span class="number">1</span>); <span class="comment">// 66 大写字母A被当作65进行处理</span></span><br><span class="line">		<span class="comment">//计算机的底层会用一个数字（二进制）来代表字符A，就是65</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span> num4 = <span class="number">40</span>; <span class="comment">//右侧的数值大小不能超过左侧的类型范围 40 &lt; 127 不会报错</span></span><br><span class="line">		<span class="keyword">byte</span> num5 = <span class="number">50</span>;</span><br><span class="line">		<span class="comment">//byte + byte --&gt; int + int --&gt; int --&gt;byte 大范围变小范围，需要强制类型转换</span></span><br><span class="line">		<span class="keyword">byte</span> result1  = (<span class="keyword">byte</span>)(num4 + num5);</span><br><span class="line">		System.out.println(result1); <span class="comment">//90</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.10.13</p>
<h2 id="编码表">编码表</h2>
<p><strong>数字和字符的对照关系表（编码表）:</strong> - <code>ASCII: American Standard Code for Information Interchange</code> 美国信息交换标准代码，48代表'0'；65代表大写字母'A'；97代表小写字母'a' ；<strong>一个中文占2个字节</strong> - <code>Unicode</code> 万国码，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。其中 <code>UTF-8</code>：<strong>一个中文占3个字节</strong></p>
<h1 id="运算符">运算符</h1>
<p>运算符：进行特定操作的符号 表达式：用运算符连起来的式子</p>
<h2 id="算数运算符">算数运算符</h2>
<ul>
<li>四则运算符：加减乘除（`+ - * /<code>） 对于整数表达式来说，除法</code>/`用的是整除，只看商，不看余数</li>
<li>取模运算（取余数）：<code>%</code></li>
<li>自增运算符：<code>++</code> ；自减运算符：<code>--</code>
<ul>
<li>单独使用时，<code>前++</code>与<code>后++</code>没有任何区别</li>
<li>混合使用时：
<ul>
<li>如果是<code>前++</code>，立刻让变量+1，然后拿着结果进行使用</li>
<li>如果是<code>后++</code>，首先使用变量本来的数值，然后再让变量+1</li>
</ul></li>
</ul></li>
</ul>
<p><strong>注意事项：</strong> 1.一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种 2.只有变量才能使用自增、自减运算符。常量不能改变，所以不能用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06operator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">		System.out.println(num1); <span class="comment">// 10</span></span><br><span class="line">		++num1; <span class="comment">// 单独使用，前++</span></span><br><span class="line">		System.out.println(num1); <span class="comment">// 11</span></span><br><span class="line">		num1++; <span class="comment">// 后++</span></span><br><span class="line">		System.out.println(num1) <span class="comment">// 12</span></span><br><span class="line">		System.out.println(<span class="string">"============"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 与打印操作混合</span></span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">		System.out.println(++num2); <span class="comment">// 21 先++</span></span><br><span class="line">		System.out.println(<span class="string">"============"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num3 = <span class="number">30</span>;</span><br><span class="line">		System.out.println(num3++); <span class="comment">// 30 后++，首先使用变量本来的30，然后再让变量+1</span></span><br><span class="line">		System.out.println(num3); <span class="comment">// 31</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line">		<span class="comment">// 11 + 20</span></span><br><span class="line">		<span class="keyword">int</span> result3 = ++x + y--;</span><br><span class="line">		System.out.println(result3); <span class="comment">// 31</span></span><br><span class="line">		System.out.println(x); <span class="comment">// 11</span></span><br><span class="line">		System.out.println(y); <span class="comment">// 19</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符">赋值运算符</h2>
<p>分为：基本赋值运算符<code>=</code>和复合赋值运算符<code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></p>
<p><strong>注意事项：</strong> 1. 只有变量才能使用赋值运算符，常量不能进行赋值 2. 复合赋值运算符其中隐含了一个强制类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> num = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// byte类型在执行运算时会先转换成int</span></span><br><span class="line"><span class="comment">// num = num + 5</span></span><br><span class="line"><span class="comment">// num = byte + int</span></span><br><span class="line"><span class="comment">// num = int</span></span><br><span class="line"><span class="comment">// num = (byte)int 这里隐含了一个强制转换 </span></span><br><span class="line">num += <span class="number">5</span>;</span><br><span class="line">System.out.println(num); <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<h2 id="比较运算符">比较运算符</h2>
<p><code>==</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>!=</code>变量与变量之间，常量与常量之间，变量与常量之间，都可以使用。</p>
<p><strong>注意事项：</strong> 1. 比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false。 2. 如果进行多次判断，不能连着写。 3. 关于<code>==</code> 详情见<strong>24.1 Object类</strong>中的 <code>equals</code> 方法</p>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p><code>短路与（并且） &amp;&amp;</code> <code>短路或（或者） ||</code> <code>非（取反） ！</code> <code>&amp;&amp;</code>与<code>||</code>具有短路效果，节省性能。</p>
<p><strong>注意事项：</strong> 1. 逻辑运算符只能用于boolean值 2. 与、或需要左右各有一个boolean。取反只需要一个 3. 与、或两种运算符，如果有多个条件，可以连续写</p>
<h2 id="三元运算符">三元运算符</h2>
<p>格式： <code>数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;</code></p>
<p>首先判断条件是否成立： - 如果成立为true，将表达式A的值赋值给左侧的变量 - 如果不成立为false，将表达式B的值赋值给左侧的变量 二者选其一</p>
<p><strong>注意事项：</strong> 1. 必须同时保证表达式A和表达式B都符合左侧的数据类型的要求。 2. 三元运算符的结果必须被使用，要么赋值，要么直接输出。</p>
<h2 id="编译器优化">编译器优化</h2>
<ol type="1">
<li>对于<code>byte short char</code>类型赋值，如果右侧赋值数值没有超过范围，编译器自动补上强转；若超过范围，编译器报错。</li>
<li>在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量。那么编译器会直接将若干个常量表达式计算得到结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">5</span>; <span class="comment">// 5 没有超过 short的范围，正确 a是short型</span></span><br><span class="line"><span class="keyword">short</span> b = <span class="number">8</span>; <span class="comment">// 正确 b是short型</span></span><br><span class="line"><span class="comment">// 65没有超过char的数值范围；</span></span><br><span class="line"><span class="comment">// int --&gt; char 数值范围又大变小 不能自动转，需要强转</span></span><br><span class="line"><span class="comment">// 编译器自动补上一个隐含的(char)</span></span><br><span class="line"><span class="keyword">char</span> zifu = <span class="comment">/*(char)*/</span> <span class="number">65</span>;</span><br><span class="line">System.out.println(zifu); <span class="comment">// A</span></span><br><span class="line"><span class="comment">// short在执行运算时自动转换成int型，运算结果自然是int型</span></span><br><span class="line"><span class="comment">//short + short --&gt; int + int = int</span></span><br><span class="line">shrot result = a + b; <span class="comment">//编译报错！左侧是short 右侧结果是int 缺少强制转换！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> result = <span class="comment">/*(short)*/</span> (<span class="number">5</span> + <span class="number">8</span>); <span class="comment">//编译器优化功能，右侧全是常量，可以直接计算结果，计算完结果后，可以自动补上强转(short)</span></span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> result2 = <span class="number">5</span> + a + <span class="number">8</span>; <span class="comment">//编译器报错！右侧有变量，不能直接计算，int转short需要强转</span></span><br></pre></td></tr></table></figure>
<p>上述记录于2019.10.14</p>
<h1 id="流程控制">流程控制</h1>
<p>需要清楚每条语句的执行流程，即各条语句的执行顺序</p>
<h2 id="顺序结构">顺序结构</h2>
<p>这个就不解释了。。。。</p>
<h2 id="判断结构">判断结构</h2>
<ol type="1">
<li><strong>if语句第一种格式：</strong><code>if</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">	语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>if语句第二种格式：</strong><code>if...else</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>if语句第三种格式：</strong><code>if...else if...else</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">	执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择结构">选择结构</h2>
<p><strong>选择语句：</strong> <code>switch</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;  <span class="comment">// 括号里就是一个表达式，计算结果不一定是一个boolean值</span></span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>: </span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;  <span class="comment">//遇到break 结束</span></span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 所有的case都和表达式结果不匹配，就执行default</span></span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch 语句使用的注意事项</span></span><br><span class="line"><span class="comment">1.多个case后面的数值不可以重复</span></span><br><span class="line"><span class="comment">2.switch后面小括号当中只能是下列数据类型：</span></span><br><span class="line"><span class="comment">基本数据类型：byte/short/char/int</span></span><br><span class="line"><span class="comment">引用数据类型：String/enum以及上述四个基本数据类型的包装类</span></span><br><span class="line"><span class="comment">3.switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略</span></span><br><span class="line"><span class="comment">匹配哪一个case就从哪一个位置向下执行，知道遇到了break或者整体结束为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08SwitchNotice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">switch</span> (num) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 1 2 先后顺序可以颠倒</span></span><br><span class="line">				System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">				<span class="comment">// break 可以省略 省略之后，遇到下一个case直接“穿透” 执行下面的语句。</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//穿透case</span></span><br><span class="line">				System.out.println(<span class="string">"我好"</span>); <span class="comment">// 继续执行</span></span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// 结束 最后的输出结果 “你好 \回车 我好”</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			case 1:</span></span><br><span class="line"><span class="comment">				System.out.println("他好"); // 编译报错，case后面的值不能重复</span></span><br><span class="line"><span class="comment">				break;</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">"大家好"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				System.out.println(<span class="string">"我也好"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环结构">循环结构</h2>
<p>循环结构的基本组成部分，一般可以分成<strong>四部分：</strong> 1. 初始化语句：在循环开始最初执行，而且只做唯一一次。 2. 条件判断： 如果成立，则循环继续；如果不成立，则循环退出。 3. 循环体：重复要做的事情内容，若干行语句。 4. 步进语句：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次。</p>
<ol type="1">
<li><strong>循环语句1：</strong> <code>for</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始表达式;布尔表达式;步进表达式) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>循环语句2：</strong><code>while</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始表达式;</span><br><span class="line"><span class="keyword">while</span> (布尔表达式)  &#123;</span><br><span class="line">	循环体;</span><br><span class="line">	步进表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>循环语句3：</strong> <code>do-while</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式;</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 第一次是无条件执行，不管循环条件是否成立，至少执行一次</span></span><br><span class="line">	循环体;</span><br><span class="line">	步进表达式;</span><br><span class="line">&#125; <span class="keyword">while</span> (布尔表达式);</span><br></pre></td></tr></table></figure>
<p><strong>三种循环的区别：</strong> - 如果条件判断从来没有满足过，那么<code>for</code> 循环和<code>wile</code> 循环将会执行0次，但是<code>do-while</code> 循环会执行至少一次 - <code>for</code> 循环的变量在小括号当中定义，只有循环内部才可以使用。<code>while</code> 循环和<code>do-while</code> 循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。</p>
<p><strong>小建议：凡是次数确定的场景，多用for循环；否则多用while循环</strong></p>
<ol start="4" type="1">
<li><strong>死循环</strong> 永远停不下来的循环，编译可以通过，可以运行，有时会使用到</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是死循环后面加上的语句无法执行，会报错！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16DeadLoop</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello, World!"</span>); </span><br><span class="line">        &#125; <span class="comment">// 死循环可以正常编译，可以运行！</span></span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>); <span class="comment">// 编译报错！ 死循环结束不了，后面的语句执行不到。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li><strong>循环的嵌套</strong> 很好理解，循环内部写一个循环。</li>
</ol>
<h1 id="条件控制">条件控制</h1>
<ol type="1">
<li><code>break</code>语句</li>
</ol>
<p>break的用法有常见的两种： 1. 可以用在switch语句到那个中，一旦执行，整个switch语句立刻结束 2. 还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。</p>
<ol start="2" type="1">
<li><code>continue</code>语句</li>
</ol>
<p>一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo15Continue</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">4</span>) &#123; <span class="comment">//如果当前是第四层</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//那么跳过当前次循环，马上开始下一次循环（第5层）</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i + <span class="string">"层到了。"</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1层到了。</span></span><br><span class="line"><span class="comment">2层到了。</span></span><br><span class="line"><span class="comment">3层到了。</span></span><br><span class="line"><span class="comment">5层到了。</span></span><br><span class="line"><span class="comment">6层到了。</span></span><br><span class="line"><span class="comment">7层到了。</span></span><br><span class="line"><span class="comment">8层到了。</span></span><br><span class="line"><span class="comment">9层到了。</span></span><br><span class="line"><span class="comment">10层到了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.10.15</p>
<p># IDE</p>
<p>方便java开发的软件。 存储结构：一个项目<code>project</code> ---（多个）模块<code>module</code> ----（多个）包<code>package</code> ---- 文件（可以是包，可以是java文件）</p>
<p><strong>常用的Intelij IDEA 快捷键 ：</strong> <code>alt + 空格</code> 导入包 <code>ctrl + Y</code> 删除当前行 <code>ctrl + D</code> 复制当前行 <code>ctrl + alt + L</code> 格式化 <code>ctrl + /</code> 添加注释 <code>ctrl + shift + /</code> 多行注释 <code>alt + ins</code> 自动生成代码 <code>alt + shift + 上下箭头</code> 移动代码行 <code>alt + 回车</code> 自动添加代码！很常用！我经常用它来 Introduce local variable</p>
<p># 方法</p>
<p>将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能 当我们需要这个功能时，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</p>
<h2 id="方法的概念">方法的概念</h2>
<p>方法其实就是<code>若干语句的功能集合</code> 方法好比一个工厂。 蒙牛工厂 原料：奶牛、饲料、水 产出物：奶制品 钢铁工厂 原料：铁矿石、煤炭 产出物：钢铁建材 参数（原料）：进入方法的数据 返回值（产出物）：从方法中出来的数据</p>
<h2 id="定义方法">定义方法</h2>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称(参数类型 参数名称, ...) &#123;    </span><br><span class="line">	方法体</span><br><span class="line">	<span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符： 现阶段的固定写法，public static 返回值类型： 也就是方法最终产生的数据结果是什么类型 方法名称: 方法的名字，规则和变量一样. 小驼峰 参数类型：进入方法的数据是什么类型 参数名称：进入方法的数据对应的变量名称 PS: 参数如果有多个，使用逗号进行分隔 方法体：方法需要做的事情，若干行代码 return: 两个作用。1. 停止当前方法 2.将后面的结果数据（返回值）还给调用处 返回值：也就是方法执行后最终产生的数据结果 return 后面的返回值，必须和方法名称前面的返回值类型，保持对应</p>
<h2 id="方法的调用格式">方法的调用格式</h2>
<ol type="1">
<li>单独调用： 方法名称(参数)；</li>
<li>打印调用： System.out.println(方法名称(参数));</li>
<li>赋值调用： 数据类型 变量名称 = 方法名称(参数);</li>
</ol>
<p><strong>注意：无返回值的方法，只能进行单独调用！</strong></p>
<h2 id="方法的调用流程">方法的调用流程</h2>
<ol type="1">
<li>找到方法</li>
<li>参数传递</li>
<li>执行方法体</li>
<li>若有返回值，带着返回值回到方法的调用处</li>
</ol>
<h2 id="方法定义的注意事项">方法定义的注意事项</h2>
<ol type="1">
<li>方法应该定义在类当中，不能在方法中再定义方法。不能嵌套</li>
<li>方法定义的前后顺序无所谓</li>
<li>方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用</li>
<li>如果方法有返回值，必须写“return 返回值;” 不能没有</li>
<li>return后面的返回值数据，必须和方法的返回值类型 对应起来</li>
<li>对于一个void没有返回值的方法，不能写return后面的返回值， 只能写return自己。</li>
<li>对于void方法当中最后一行的return可以省略不写</li>
<li>一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到。</li>
<li>两个return不能连写</li>
</ol>
<h1 id="overload-重载">Overload 重载</h1>
<p>本来可以归并到方法里讲的，但是我给他单独列出来，因为它的确很重要，而且很容易和后面的方法覆盖重写 Override 搞混淆。</p>
<ul>
<li><p><strong>为什么使用方法重载：</strong> 对于功能类似的方法来说，因为参数列表不一样，却要记住那么多不同的方法名称，太麻烦 可不可以只需要记住一个方法名称，就可以实现类似的多个功能呢？</p></li>
<li><p><strong>方法的重载（Overload）：</strong> 多个方法的名称一样，但是参数列表不一样。</p></li>
<li><p><strong>方法重载与下列因素相关：</strong></p></li>
</ul>
<ol type="1">
<li>参数个数不同 （可变参数在参数类型确定、个数不确定时使用）</li>
<li>参数类型不同</li>
<li>参数的多类型顺序不同</li>
</ol>
<ul>
<li><strong>方法重载与下列因素无关</strong></li>
</ul>
<ol type="1">
<li>参数名称</li>
<li>方法的返回值类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;...&#125;  <span class="comment">// 原始方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;...&#125; <span class="comment">// 正确重载</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;...&#125; <span class="comment">// 代码错误 和第8行冲突 重载和修饰符没关系</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;...&#125; <span class="comment">// 正确重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;...&#125; <span class="comment">// 代码错误 和第6行冲突 重载和参数名称无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span> </span>&#123;...&#125; <span class="comment">// 代码错误 和第5行冲突</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OPEN</span><span class="params">()</span> </span>&#123;...&#125;  <span class="comment">// 代码正确不会报错，但是并不是有效重载 因为方法名字不一样！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;...&#125; <span class="comment">// 代码错误 和第3行冲突</span></span><br></pre></td></tr></table></figure>
<p>上述记录于2019.10.16</p>
<h1 id="数组">数组</h1>
<p>是一种容器，可以同时存放多个数据值。</p>
<ul>
<li><strong>数组的特点：</strong></li>
</ul>
<ol type="1">
<li>数组是一种引用类型 （所以直接打印的话出现的是数组的地址值）</li>
<li>数组中的多个数据类型必须统一</li>
<li>数组的长度在程序运行期间不可改变 （2、3也是和集合的区别所在）</li>
</ol>
<ul>
<li><strong>数组的初始化：</strong> 在内存中创建一个数组，并且向其中赋予一些默认值</li>
</ul>
<ol type="1">
<li>动态初始化：（指定长度）</li>
<li>静态初始化：（指定内容）</li>
</ol>
<ul>
<li><strong>动态初始化格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[数组长度]</span><br><span class="line">数组名称[<span class="number">0</span>] = 要存的元素<span class="number">1</span></span><br><span class="line">数组名称[<span class="number">1</span>] = 要存的元素<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果是整数类型，默认为0 如果是浮点类型，默认为0.0 如果是字符类型，默认为<code>'\u0000'</code> 一种特殊的字符，不是空但是<strong>打印不出来</strong> 如果是布尔类型，默认为false 如果是引用类型，默认为null <strong>可以打印出来</strong></p>
<ul>
<li><strong>静态初始化格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[] &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;;</span><br><span class="line">数据类型[] 数组名称 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然没指定长度，但是可以根据大括号里的元素自动推算出长度。 也有默认值，只不过系统自动马上将默认值替换为了大括号当中的具体数值。</p>
<ul>
<li><p><strong>使用建议：</strong> 如果不确定数组当中的具体内容，用动态初始化；否则用静态初始化。</p></li>
<li><p><strong>常见问题：</strong></p></li>
</ul>
<ol type="1">
<li>如果访问数组元素的时候，索引编号并不存在，将会发生数组索引越界异常：<code>ArrayIndexOutOfBoundsException</code></li>
<li>数组必须进行new初始化才能使用其中的元素。如果只是赋值了一个null，没有进行new，将会放生空指针异常：<code>NullPointerException</code></li>
<li>将数组当作方法的参数时，方法接收的是数组的地址。</li>
<li>当方法返回参数是数组时，方法返回的是数组的地址。（3、4两点会在11中详细解释！）</li>
</ol>
<ul>
<li><strong>缺点：</strong> 数组一旦创建，程序运行期间，长度不可改变</li>
</ul>
<h1 id="java的内存划分">Java的内存划分</h1>
<p><strong>5个部分</strong> 1. <strong>栈（Stack）：</strong> 存放的都是方法中的局部变量。<font color=red>方法的运行一定要在栈当中运行</font> 局部变量：方法的参数，或者是方法{}内部的变量 作用域：一旦超出作用域，立刻从占内存种消失</p>
<ol start="2" type="1">
<li><p><strong>堆（Heap）：</strong> <font color=red>凡是new出来的东西，都在堆当中</font> 成员变量：类中的定义的变量，在方法外边 字符串常量池 详情见<strong>14.1 字符串常量池</strong> 堆内存里面的东西都有一个地址：16进制 堆内存里面的数据都有默认值：规则同数组。</p></li>
<li><p><strong>方法区（Method Area）：</strong> 存储 .class相关信息，包含方法的信息、常量、静态变量（static）</p></li>
<li><p><strong>本地方法栈（Native Method Stack）：</strong> 与操作系统相关</p></li>
<li><p><strong>寄存器（pc Register）：</strong> 与CPU相关</p></li>
</ol>
<p><img src="\image\11.png" alt="16.2" />上述记录于2019.10.19</p>
<h1 id="面向对象">面向对象</h1>
<p><strong>面向过程：</strong> 当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节。</p>
<p><strong>面向对象：</strong> 当需要实现一个功能的时候，不关心具体步骤，而是找一个已经具有该功能的人，来帮我做事儿。 面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。</p>
<p><strong>特点：</strong> 三大基本特征：封装、继承和多态。</p>
<h2 id="类和对象">类和对象</h2>
<ul>
<li>类： 是一组相关属性和行为的集合。可以看成是一类事物的模板
<ul>
<li>属性：是什么</li>
<li>行为：能做什么</li>
</ul></li>
<li>对象：是一类事物的具体体现。</li>
</ul>
<h2 id="类和对象的关系">类和对象的关系</h2>
<ul>
<li>类是对一类事物的描述，是抽象的</li>
<li>对象是一类事物的实例，是具体的</li>
<li>类是对象的模板，对象是类的实体</li>
</ul>
<h2 id="类的定义">类的定义</h2>
<p>成员变量（属性） 成员方法（行为）</p>
<p><strong>注意事项：</strong> 1. 成员变量是直接定义在类当中的，在方法外边 2. 成员方法不要写 <code>static</code> 关键字（静态方法是类的方法）</p>
<h2 id="对象的创建">对象的创建</h2>
<p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用 1. 导包：也就是指出需要使用的类在什么位置 <code>import 包名称,类名称;</code> 对于和当前类属于同一个包的情况，可以省略导包语句不写 2. 创建格式： <code>类名称 对象名 = new 类名称();</code> 3. 使用，分两种情况： - 使用成员变量： <code>对象名.成员变量名</code> - 使用成员方法： <code>对象名.成员方法名(参数)</code> 也就是，想用谁，就用对象名点儿谁</p>
<p><strong>注意事项：</strong> 如果成员变量没有进行赋值，那么将会有一个默认值、规则和数组一样 当一个对象作为参数，传递到方法当中时，实际上传递进去的是对象的地址值 当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day06.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部变量和成员变量</span></span><br><span class="line"><span class="comment">1. 定义的位置不一样</span></span><br><span class="line"><span class="comment">局部：在方法内部</span></span><br><span class="line"><span class="comment">成员：在方法外部，直接写在类当中</span></span><br><span class="line"><span class="comment">2. 作用范围不一样</span></span><br><span class="line"><span class="comment">局部：只有方法当中才可以使用，出了方法就不能再使用</span></span><br><span class="line"><span class="comment">成员：整个类全部都可以通用</span></span><br><span class="line"><span class="comment">3. 默认值不一样</span></span><br><span class="line"><span class="comment">局部：无默认值，如果要使用，必须手动进行赋值</span></span><br><span class="line"><span class="comment">成员变量：如果没有赋值，会有默认值，规则和数组一样</span></span><br><span class="line"><span class="comment">4. 内存的位置不一样</span></span><br><span class="line"><span class="comment">局部：位于栈内存</span></span><br><span class="line"><span class="comment">成员：位于堆内存</span></span><br><span class="line"><span class="comment">5. 生命周期不一样</span></span><br><span class="line"><span class="comment">局部：随着方法进栈而诞生，随着方法出栈而消失</span></span><br><span class="line"><span class="comment">成员：随着对象创建而诞生，随着对象被垃圾回收而消失</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01VariableDifference</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123; <span class="comment">// 方法的参数就是局部变量</span></span><br><span class="line"><span class="comment">//        System.out.println(num); 报错 这是methodA方法的局部变量，已经超过了作用域</span></span><br><span class="line">        <span class="comment">// 参数在方法调用的时候，必然会被赋值！所以不会报错！</span></span><br><span class="line">        System.out.println(param);</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//        System.out.println(age); 报错 局部变量没赋值不能用</span></span><br><span class="line">        System.out.println(name); <span class="comment">// 成员变量 虽然没赋值但是有默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装">封装</h2>
<ol type="1">
<li>方法是一种封装</li>
<li>关键字 <code>private</code> 也是一种封装 封装就是将一些细节信息隐藏起来，对于外界不可见。</li>
</ol>
<h2 id="private关键字">private关键字</h2>
<p>一旦使用 <code>private</code> 进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问。 间接访问 <code>private</code> 成员变量，定义一堆 <code>Getter/Setter</code> 方法 必须叫 <code>setXXX</code> 或者 <code>getXXX</code> 命名规则 <code>Getter</code> 不能有参数，返回值类型和成员变量对应。 <code>Setter</code> 不能有返回值，参数类型和成员变量对应。</p>
<h2 id="this关键字">this关键字</h2>
<p>当方法的局部变量和类的成员变量重名的时候，根据<strong>“就近原则”</strong>，优先使用局部变量。 如果需要访问本类当中的成员变量，需要使用格式： <code>this.成员变量</code> <font color= red><strong>哪个对象调用的方法，方法里的this就是那个对象</strong></font> 详情见18.2</p>
<p>上述记录于2019.10.21</p>
<h2 id="构造方法">构造方法</h2>
<p>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名称(参数类型 参数名称) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong> 1. 构造方法的名称必须和所在的类名称完全一样，就连大小写都要一样 2. 构造方法不要写返回值类型，连void都不写 3. 构造方法不能return 一个具体的返回值 4. <strong>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做</strong> 5. <strong>一旦编写了至少一个构造方法，那么编译器将不再赠送</strong> 6. 构造方法也是可以进行重载的</p>
<h2 id="一个标准的类">一个标准的类</h2>
<ol type="1">
<li>所有的成员变量都要使用 <code>private</code> 关键字修饰</li>
<li>为每一个成员变量编写一对儿 <code>Getter/Setter</code> 方法</li>
<li>编写一个无参数的构造方法</li>
<li>编写一个全参数的构造方法 标准类被称为<code>Java Bean</code></li>
</ol>
<p>上述记录于2019.10.22</p>
<h2 id="匿名对象">匿名对象</h2>
<p>只有右边的对象，没有左边的名字和赋值运算符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名称();</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong> 1. 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。 2. 如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。</p>
<h1 id="常用api-一">常用API （一）</h1>
<p><code>Application Programing Interface</code> 应用程序编程接口是JDK中提供给我们直接使用的类 API文档就是程序员的字典 主要看 包路径、构造方法、方法摘要</p>
<p><strong>引用类型的一般使用步骤：</strong> 1. 导包 只有<code>java.lang</code> 包下的内容不需要导包，其他的包都需要 <code>import</code> 语句 2. 创建 3. 使用</p>
<h2 id="scanner">Scanner</h2>
<p>一个可以解析基本类型和字符串的文本扫描器。可以实现键盘输入数据，到程序当中。 <code>new Scanner(System.in)</code> 生成一个Scanner对象，并接收输入 <code>int nextInt()</code> ：返回你所输入的整型数 <code>String next()</code> ：返回你所输入的字符串 详情参见API</p>
<p>上述记录于2019.10.25-----</p>
<h2 id="random">Random</h2>
<p>Random类用来生成随机数字。 <code>nextInt(无参数)</code>：获取一个随机的int数字（范围是int所有范围，有正负） <code>nextInt(有参数)</code>：获取一个随机的int数字（参数代表了范围，左闭右开区间） 详情参见API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> anInt = r.nextInt(<span class="number">5</span>); <span class="comment">// 左闭右开 [0,5)</span></span><br></pre></td></tr></table></figure>
<h2 id="arraylist">ArrayList</h2>
<p>前面说过，数组的长度不可以发生改变。（详情见10） 但是<strong>集合</strong><code>ArrayList&lt;E&gt;</code>的长度是可以随意变化的。（后面还会介绍更多种集合） &lt;E&gt; 代表泛型：也就是装在集合当中的所有元素，全都是统一的什么类型，只能是引用类型，不能是基本类型。 从JDK 1.7+开始，右侧的尖括号内容可以不写，但是&lt;&gt;本身还是要写。 <code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</code></p>
<p><strong>注意事项：</strong> 1. 对于ArrayList集合来说，直接打印得到的不是地址值，而是内容（说明它覆盖重写了toString方法） 2. 如果内容是空的，得到的是空的中括号：[] 详情参见API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList当中的常用方法：</span></span><br><span class="line"><span class="comment">public boolean add(E e): 向集合当中添加元素</span></span><br><span class="line"><span class="comment">public E get(int index)：集合当中获取元素</span></span><br><span class="line"><span class="comment">对于ArrayList集合来说，add添加动作一定成功，返回值可以不用</span></span><br><span class="line"><span class="comment">但是其他集合不一定成功（有的集合不能添加重复的元素，后面会学到）</span></span><br><span class="line"><span class="comment">public E remove(int index)：从集合当中删除元素</span></span><br><span class="line"><span class="comment">public int size()：获取集合的尺寸长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ArrayListMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向集合当中添加元素：add</span></span><br><span class="line">        <span class="keyword">boolean</span> success = list.add(<span class="string">"五六七"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"添加的动作是否成功"</span> + success);</span><br><span class="line">        list.add(<span class="string">"梅十三"</span>);</span><br><span class="line">        list.add(<span class="string">"鸡大保"</span>);</span><br><span class="line">        list.add(<span class="string">"小飞"</span>);</span><br><span class="line">        list.add(<span class="string">"江主任"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从集合当中获取元素</span></span><br><span class="line">        String name = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"第2号索引位置"</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从集合中删除元素</span></span><br><span class="line">        String whoRemoved = list.remove(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"被删除的人是："</span> + whoRemoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取集合的长度尺寸</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        System.out.println(<span class="string">"集合的长度是 "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day07.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的包装类</span></span><br><span class="line"><span class="comment">包装类是引用类型，都位于java.lang包下</span></span><br><span class="line"><span class="comment">从JDK 1.5+开始，支持自动装箱、自动拆箱：基本类型--&gt; 包装类型、包装类型--&gt;基本类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05ArrayListBasic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//错误写法！泛型只能是引用类型，不能是基本类型 因为ArrayList存储的是一个地址，基本类型，没有地址</span></span><br><span class="line">        <span class="comment">//ArrayList&lt;int&gt; listB = new ArrayList&lt;int&gt;();</span></span><br><span class="line">        ArrayList&lt;Integer&gt; listC = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listC.add(<span class="number">100</span>);</span><br><span class="line">        listC.add(<span class="number">200</span>);</span><br><span class="line">        System.out.println(listC);</span><br><span class="line">        <span class="keyword">int</span> num = listC.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一号元素是 "</span> + num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.10.26</p>
<h1 id="string-字符串">String 字符串</h1>
<p><code>java.lang.String</code>类代表字符串。 程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是） 字符串是常量；它们的值在创建之后不能更改。</p>
<p><strong>字符串的特点：</strong> 1. <strong>字符串的内容永远不可变</strong> 2. 因为字符串内容不可改变，所以可以共享使用 3. 字符串效果上，相当于是<code>char[]</code>字符数组，但是底层原理是byte[]字节数组</p>
<p><strong>创建字符串的常见3+1种方式：</strong> - 三种构造方法 1. <code>public String();</code> 创建一个空白字符串，不含有任何内容 2. <code>public String(char[] array);</code> 根据字符数组的内容。来创建对应的字符串 3. <code>public String(byte[] array);</code> 根据字节数组的内容来创建对应的字符串 - 一种直接创建 <code>String str = "Hello"; // 右边直接用双引号</code> 没有new，直接写上双引号，就是字符串对象</p>
<h2 id="字符串常量池">字符串常量池</h2>
<p>从JDk1.7+ 常量池在堆内存中。<strong>注意：直接双引号的字符串，去常量池里找，没有则在常量池里生成，new的不去常量池！！直接在常量池外new。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符串常量池：</span></span><br><span class="line"><span class="comment">程序当中直接写上的双引号字符串，就在字符串常量池中。</span></span><br><span class="line"><span class="comment">new的不在常量池当中</span></span><br><span class="line"><span class="comment">对于基本类型来说，== 是进行数值的比较</span></span><br><span class="line"><span class="comment">对于引用类型来说，== 是进行地址值的比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// true 都在常量池里，地址相同</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">// false 一个在常量池，一个在池外new，地址不同</span></span><br><span class="line">        System.out.println(str2 == str3); <span class="comment">// false 同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="\image\14.1.png" alt="" /><figcaption>16.2</figcaption>
</figure>
<p><code>==</code> 是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两种方法：</p>
<ol type="1">
<li><code>public boolean equals(Object obj);</code>
<ul>
<li>任何对象都能用Object进行接收</li>
<li>具有对称性，a.equals(b) 与 b.equals(a) 效果一样</li>
<li>如果比较双方一个常量一个变量，推荐把常量字符串写在前面</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="string">"Hello"</span>.equals(str); <span class="comment">// 推荐常量写在前面 false</span></span><br><span class="line">str.equals(<span class="string">"Hello"</span>); <span class="comment">//不推荐常量写在后面，这种情况会报错，空指针异常，NullPointerException</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><code>public boolean equalsIgnoreCase(String str);</code> 忽略大小写，进行内容比较 只有英文字母区分大小写其他都不区分大小写</li>
</ol>
<h2 id="string常用方法">String常用方法</h2>
<p><strong>String 当中与转换相关的常用方法：</strong> <code>public char[] toCharArray()</code> 将当前字符串拆分成为字符数组作为返回值 <code>public byte[] getBytes()</code> 获得当前字符串底层的字节数组 <code>public String replace(CharSequence oldString, CharSequence newString)</code> 将所有出现的老字符串替换成新的字符串，返回替换之后的结果新字符串 <code>CharSequence</code> 是个接口，意思就是说，可以接收字符串类型</p>
<p><strong>String 当中与获取相关的常用方法：</strong> <code>public int length()</code> 获取字符串长度 <code>public String concat(String str)</code> 拼接字符串 <code>public char chaAt(int index)</code> 获取指定索引位置的单个字符 <code>public int indexOf(String str)</code> 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1</p>
<p><strong>字符串的截取方法：</strong> <code>public String substring(int index)</code> <code>public String substring(int begin, int end)</code> 左闭右开 [begin, end)</p>
<p><strong>分隔字符串的方法：</strong> <code>public String[] split(String regex)</code> 按照参数的规则，将字符串切分成若干部分 regex参数其实是一个正则表达式</p>
<p>上述记录于2019.10.27</p>
<h1 id="静态static-关键字">静态（static 关键字）</h1>
<p>一旦用了<code>static</code> 关键字 那么这样的内容不在属于对象自己而是属于类的 凡是本类的对象，都共享同一份 无论是成员变量还是成员方法，一旦使用了static，都推荐使用类名称进行调用 如果是用对象名称调用，编译器在编译时会自动转换成类名称调用</p>
<p><strong>注意事项：</strong> 1. 静态不能直接访问非静态 原因：内存当中是先有静态内容，后有非静态内容 2. 静态方法当中不能用this 原因：this代表当前对象。但<strong>静态与对象没有关系，只和类有关系</strong>。 3. 关于静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当第一次用到本类时，静态代码块执行唯一的一次</li>
<li>静态内容总是优先于非静态，所以静态代码块比构造方法先执行</li>
<li>静态代码块的典型用途，用来一次性地对静态成员变量进行赋值</li>
</ul>
<h1 id="常用工具类">常用工具类</h1>
<p>下面介绍的几个工具类，都提供了大量的<strong>静态方法</strong>， 所以不需要new对象，直接可以通过类名调用</p>
<h2 id="arrays">Arrays</h2>
<p>一个与数组相关的工具类，提供了大量静态方法。用来实现数组的常见操作。 <code>public static String toString(数组)</code> 将参数数组编程字符串，按照默认格式<code>[元素1,元素2,元素3,...]</code> <code>public static void sort(数组)</code> 按照默认升序（从小到大） 对数组的元素进行排序 如果是数值，默认升序 从小到大 如果是字符串 ，默认按照字母升序 如果是自定义类 这个自定义类需要有<code>Comparable</code>或者<code>Cmoparator</code>接口支持（后面要讲的覆盖重写）</p>
<h2 id="math">Math</h2>
<p>是数学相关的工具类，里面提供了大量的静态方法，完成与数学相关的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">//绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">// 向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">// 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">//四舍五入</span></span><br><span class="line">Math.PI 代表近似的圆周率常量</span><br></pre></td></tr></table></figure>
<h2 id="collections">Collections</h2>
<p>是集合相关的工具类，里面提供了大量的静态方法，完成与集合相关的操作<strong>详情见 32 Collections类</strong></p>
<p>上述记录于2019.10.28</p>
<h1 id="继承">继承</h1>
<p>继承主要解决的问题就是：共性抽取</p>
<p><strong>继承关系当中的特点：</strong> 1. 子类可以拥有父类的内容 2. 子类还可以拥有自己专有的内容</p>
<h2 id="成员变量重名时">成员变量重名时：</h2>
<p>在父子类的继承关系当中，如果<strong>成员变量</strong>重名，则创建子类对象时，访问有两种方式： 1. 直接通过子类对象访问成员变量 - 等号左边(创建对象时的赋值等号)是谁，就优先用谁，没有则向上找 2. 间接通过成员方法访问成员变量 - 方法属于谁，就优先用谁，没有则向上找 <strong>多态口诀：编译看左边，运行还看左边</strong>（后面会讲多态）</p>
<h2 id="局部变量和成员变量重名时">局部变量和成员变量重名时：</h2>
<p>局部变量、本类的成员变量、父类的成员变量重名时如何区分？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 30 就近原则 局部变量</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 20 本类变量</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">// 10 父类变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员方法重名时">成员方法重名时：</h2>
<p>在父子类的继承关系当中，创建子类对象，访问<strong>成员方法</strong>的规则： 看右边创建的对象（new 的）是谁，就优先用谁的成员方法，如果没有则向上找。 <strong>（多态口诀： 编译看左边，运行看右边！）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line">obj.method(); <span class="comment">// 编译看左，左边Fu中有，运行看右，右边Zi中有，调用Zi中的method方法</span></span><br><span class="line">obj.methodFu(); <span class="comment">//编译看左，左边Fu中有，运行看右，右边Zi中没有，向上找，调用Fu中的methodFu方法</span></span><br><span class="line">obj.methodZi(); <span class="comment">//编译报错，根据口诀，编译看左，左边是Fu，Fu当中没有methodZi方法！</span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong> 1. Java语言是单继承的：一个类的直接父类只能由唯一一个。 2. Java语言可以多级继承。最顶端：<code>java.lang.Object</code>。 3. 一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。 4. 无论是调用成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。</p>
<p>上述记录于2019.10.29</p>
<h1 id="override覆盖重写">Override（覆盖）重写</h1>
<p>概念：在继承关系当中，方法的名称一样，参数列表也一样，也叫覆盖重写 而反观重载（参见<strong>9 重载</strong>）：方法名称一样，参数列表不一样</p>
<p>方法的覆盖重写特点：创建的是子类对象，优先用子类方法</p>
<p><strong>注意事项：</strong> 1. 必须保证父子类之间的方法名称相同，参数列表也相同。 - 可选的安全检测手段 <code>@override</code> ：写在方法前面，用来检测是不是有效的正确覆盖重写 2. 子类方法的返回值，必须<strong>小于等于</strong>父类方法的返回值 3. 子类方法的权限，必须<strong>大于等于</strong>父类方法的权限修饰符 - <code>public &gt; protected &gt; (default) &gt; private</code> - <strong><code>（default）</code>不是关键字default, 而是什么都不写，留空！</strong></p>
<h2 id="super关键字">super关键字</h2>
<p>前面已经用到过，<code>super</code>关键字用来访问父类内容。</p>
<p><strong>super关键字的三种用法:</strong> 1. 在子类的成员方法中，访问父类的成员变量 2. 在子类的成员方法中，访问父类的成员方法 3. 在子类的构造方法中，访问父类的构造方法</p>
<p><strong>继承关系中，父子类构造方法的访问特点：</strong> 1. 子类构造方法当中有一个默认隐含的 <code>super();</code> 调用，所以一定是先调用父类构造方法，后执行的子类构造方法 2. 子类构造可以通过<code>super</code> 关键字，调用父类重载构造 3. <code>super()</code>的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次<code>super</code>构造</p>
<h2 id="this关键字-1">this关键字</h2>
<p><strong>this关键字用来访问本类内容，用法也有三种：</strong> 1. 在本类的成员方法中，访问本类的成员变量 2. 在本类的成员方法中，访问本类的另一个成员方法 3. 在本类的构造方法中，访问本类的另一个构造方法 - <code>this(...)</code>调用也必须是构造方法的第一个语句，也是唯一一个<code>this</code>。 此时<code>super();</code>不会赠送。 - <code>super</code>和<code>this</code>两种构造调用，不能同时使用。</p>
<h1 id="抽象">抽象</h1>
<h2 id="抽象方法">抽象方法</h2>
<p>如果父类当中的方法不确定如何进行<code>{}</code>方法体实现，那么这就应该是一个抽象方法</p>
<h2 id="抽象类">抽象类</h2>
<p>抽象类：抽象方法所在的类，必须是抽象类才行。在 <code>class</code> 之前写上 <code>abstract</code> 即可</p>
<p><strong>如何使用抽象类和抽象方法：</strong> 1. 不能直接创建 <code>new</code> 抽象类对象 2. 必须用一个子类来继承抽象父类 3. 子类必须覆盖重写抽象父类当中<strong>所有的抽象方法</strong> 覆盖重写（实现）： 子类去掉抽象方法 <code>abstract</code> 关键字，然后补上方法体大括号 4. 创建子类对象进行使用</p>
<p><strong>注意事项：</strong> 1. 抽象类不能创建对象 2. 抽象类可以有构造方法，供子类创建对象时，初始化父类成员使用。 3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定时抽象类 4. 抽象类的子类，必须重写抽象父类的<strong>所有</strong>抽象方法，否则，子类也是一个抽象类</p>
<h1 id="接口">接口</h1>
<p>接口就是多个类的公共规范，是一种引用数据类型，最重要的内容就是其中的抽象方法</p>
<p>格式类似类，关键字 <code>class</code> 换成关键字 <code>interface</code> ，编译生成的字节码文件仍然是 <code>.java --&gt; .class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puvlic <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">	<span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是Java 7 1. 常量 <code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code> 2. 抽象方法 <code>[public] [abstract] 返回值类型 方法名称(参数列表);</code></p>
<p>如果是Java 8 额外添加 3. 默认方法 <code>[public] default 返回值类型 方法名称(参数列表){方法体}</code> 4. 静态方法 <code>[public] static 返回值类型 方法名称(参数列表){方法体}</code></p>
<p>如果是Java 9 额外添加 5. 私有方法 普通私有方法: <code>private 返回值类型 方法名称(参数列表){方法体}</code> 静态私有方法: <code>private static 返回值类型 方法名称(参数列表){方法体}</code></p>
<blockquote>
<p>上述的带中括号[]的都是默认可以省略不写的，其中default 和之间在18中提到的（defualt）不同，不是留空，是要真正写出来的！</p>
</blockquote>
<p><strong>接口使用的步骤：</strong> 1. 接口不能直接使用，必须有一个“实现类” 来 “实现” 该接口 2. 接口的实现类 <code>implements 接口的类</code> ，必须覆盖重写（实现）接口中所有的抽象方法。 3. 创建实现类的对象，进行使用</p>
<h2 id="接口中的抽象方法">接口中的抽象方法</h2>
<ul>
<li>接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract，可以选择性的省略，方法的三要素（名称，参数，返回值）可以随意</li>
<li>接口的实现类（<code>implements</code>接口的类），必须覆盖重写（实现）接口中所有的抽象方法。如果实现类没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类！</li>
</ul>
<h2 id="接口中的默认方法">接口中的默认方法</h2>
<ul>
<li>接口当中的默认方法，可以解决接口升级的问题（接口在投入使用后，又要在接口中加入新的方法）固定关键字public default 其中public可以省略</li>
<li>接口的默认方法，可以通过接口实现类对象直接调用</li>
<li>接口的默认方法，也可以被接口的实现类进行覆盖重写</li>
</ul>
<h2 id="接口中的静态方法">接口中的静态方法</h2>
<ul>
<li>不能通过接口实现类的对象来调用接口当中的静态方法，应该通过接口名称直接调用其中的静态方法</li>
</ul>
<p>上述记录于2019.10.30</p>
<h2 id="接口中的私有方法">接口中的私有方法</h2>
<ol type="1">
<li>普通私有方法，解决多个默认方法之间重复代码问题</li>
<li>静态私有方法，解决多个静态方法之间重复代码问题</li>
</ol>
<h2 id="接口中的常量成员变量">接口中的常量（成员变量）</h2>
<ol type="1">
<li>必须使用public static final修饰（可以省略不写）</li>
<li>必须赋值（没有默认值），赋值后不可修改</li>
<li>常量用完全大写字母，用下划线分隔</li>
</ol>
<p><strong>注意事项：</strong> 1. 接口不能有静态代码块和构造方法 2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口 3. 如果实现类所实现的多个接口当中，存在重名的抽象方法，那么只需要覆盖重写一次即可。 4. 如果实现类所实现的多个接口当中，存在重名的默认方法，那么实现类要对重名的默认方法覆盖重写！ 5. 如果实现类没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类！ 6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突（重名），优先用父类的默认方法</p>
<p><strong>继承与实现：</strong> 1. 类与类之间是单继承的，直接父类只有一个 2. 类与接口之间是多实现的，一个类可以实现多个接口 3. 接口与接口之间是多继承的 4. 多个父接口中的抽象方法重名，没关系，子类只需要覆盖重写一个即可。 5. 多个父接口中的默认方法重名，子接口必须默认重写默认方法，而且带着 <code>default</code> ！</p>
<h1 id="多态-左父右子">多态 （左父右子）</h1>
<p><code>extends</code>继承或者<code>implements</code>实现，是多态的前提。 代码当中体现多态性，其实就是一句话：<strong>父类引用指向子类对象</strong> 格式： <code>父类名称 对象名 = new 子类名称();</code> 或者 <code>接口名称 对象名 = new 实现类名称();</code> 具体规则参见** 继承**章节！</p>
<h2 id="对象的向上转型">对象的向上转型</h2>
<p>其实就是多态写法 <code>父类名称 对象名 = new 子类名称(); Animal animal = new Cat();</code> 右侧创建一个子类对象，把它当作父类来看待使用 类似于自动类型转换： <code>double num = 100; int --&gt; double</code> <strong>向上转型一定是安全的</strong>从小范围转向了大范围 <strong>弊端：</strong> 无法调用子类原本特有的内容！因为无论是调用子类的成员方法还是成员变量，根据多态口诀，编译都要先看左（参见<strong>17继承</strong>），而左边的父类没有子类特有的内容，无法调用，编译就会报错！</p>
<h2 id="对象的向下转型">对象的向下转型</h2>
<p>其实是一个还原的动作 <code>子类名称 对象名 = (子类名称)父类对象;</code> 将父类对象，<strong>还原</strong>成为<strong>本来</strong>的子类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，只能还原成本来的子类，不能还原成父类的其他的子类</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat = (Cat) animal;</span><br><span class="line">Dog dog = (Dog) animal; <span class="comment">//编译通过，但是运行发生类转换异常ClassCastException java.lang.ClassCastException</span></span><br></pre></td></tr></table></figure>
<p>必须保证对象本来是什么，就向下转型成什么，不能转型成别的！编译会通过，但是运行会出现异常 <code>java.lang.ClassCastException</code> 类似于强制类型转换: <code>int num = (int) 10.0;// 可以  int num = (int) 10.5; //不可以 精度损失</code></p>
<h2 id="instanceof关键字">instanceof关键字</h2>
<p><code>对象 instanceof 类名称</code> 返回值 <code>boolean</code>，判断前面的对象能不能当作后面类型的实例</p>
<p>上述记录与2019.10.31</p>
<h2 id="final关键字">final关键字</h2>
<ul>
<li><strong>用来修饰一个类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前这个类不能有任何子类。（太监类） 但是一定有父类（<code>Object</code>） 其中的所有成员方法，都无法进行覆盖重写，但可以对其父类的方法做覆盖重写。</p>
<ul>
<li><strong>修饰一个方法</strong> 这个方法就是最终方法（不能被覆盖重写）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">	<span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于类和方法来说，<code>abstract</code>关键字（一定要覆盖重写）和<code>final</code>关键字（不能覆盖重写）不能同时使用，产生矛盾</strong></p>
<ul>
<li><p><strong>修饰一个局部变量</strong> 一旦使用 <code>final</code> 来修饰局部变量，这个变量就不能进行更改，并且必须赋予初始值。 <strong>一次赋值，终生不变</strong> 对于基本类型来说，不可变说的是变量当中的数值不可改变 对于引用类型来说，不可变说的是变量当中的地址值不可改变，但是地址对应的内容可以改变</p></li>
<li><p><strong>修饰一个成员变量</strong> 这个变量照样不可变 由于成员变量具有默认值，所以用了 <code>final</code> 之后，必须手动赋值，不会再给默认值了。 要么使用直接赋值，要么通过构造方法赋值。二者选其一。 当选构造方法赋值时：必须保证类当中所有重载的构造方法，都最终会对 <code>final</code> 修饰的成员变量赋值</p></li>
</ul>
<h1 id="权限修饰符">权限修饰符</h1>
<p><strong>四种权限修饰符：</strong> public &gt; protected &gt; (default) &gt; private 同一个类 yes yes yes yes 同一个包 yes yes yes no 不同包子类 yes yes no no 不同包非子类 yes no no no</p>
<h1 id="内部类">内部类</h1>
<p>一个类内部包含另一个类 内部类与外部类并不是继承关系 例如人体和心脏，汽车和发动机的关系</p>
<p>分类： 1. 成员内部类 2. 局部内部类（包含匿名内部类）</p>
<h2 id="成员内部类">成员内部类</h2>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">	修饰符 <span class="class"><span class="keyword">class</span> 内部类名称 </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内用外，可以随意访问，不受权限修饰符影响 外用内，需要借助内部类对象。</p>
<p><strong>成员内部类文件格式：</strong> 编译之前，内部类是写在外部类的<code>.java</code>文件中，编译之后与外部类分开，单独生成一个<code>外部类名称$内部类名称.class</code>文件，这也是为什么之前<strong>2.2 标识符</strong>提到不推荐用<code>$</code>命名类，就是为了这里避免混淆。</p>
<p><strong>使用内部类的两种方式：</strong> 1. 间接方式：在外部类的方法当中使用内部类；然后通过 <code>main</code> 调用外部类的方法，从而使用了内部类。 2. 直接方式：<code>外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</code></p>
<p>如果出现了重名现象，那么访问外部类成员变量的格式： <code>外部类名称.this.外部类成员变量</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 外部类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 内部类的成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123; <span class="comment">// 内部类的成员方法</span></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>; <span class="comment">// 内部类的成员方法的局部变量</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 30 就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 20 内部类成员变量</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);  <span class="comment">//10 外部类成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>一个类定义在一个方法内部，只有当前所属的方法才能使用它，出了方法外面就不能用了</p>
<p><strong>定义格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">	修饰符 返回值类型 外部类方法名称(参数列表) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> 局部类名称 </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>根据类选择权限修饰符规则：</strong> 1. 外部类：<code>public / (default)</code> 2. 成员内部类：<code>public / protected / (default) / private</code> 3. 局部内部类：什么都不能写 4. 如果希望局部内部类访问所在方法的局部变量，那么这个局部变量必须是 <code>final</code> 的。从Java 8 开始，只要局部变量实时不变，那么 <code>final</code> 关键字可以省略。</p>
<h2 id="匿名内部类">匿名内部类</h2>
<p>如果接口的实现类（或者是父类的子类） 只需要使用唯一的一次 那么这种情况下可以省略掉该类的定义，改为使用<strong>匿名内部类</strong> 定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意右边，这里不是在new接口，接口是不能直接new对象的，这里是省略的实现接口的类的名字！其实就是匿名类是在创建对象的同时进行了定义，因此只能用一次。</span></span><br><span class="line"><span class="comment">// 左边是一个多态！有对象名和赋值符 所以不是匿名对象！</span></span><br><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称() &#123; </span><br><span class="line">	<span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对格式进行解析 <code>new 接口名称() {...}</code></strong> 1. <code>new</code> 代表创建对象的动作 2. 接口名称就是匿名内部类需要实现哪个接口 3. <code>{...}</code> 这才是匿名内部类的内容</p>
<p><strong>匿名类和匿名对象（参见12.10 匿名对象）不是一个东西！</strong></p>
<ul>
<li>匿名内部类， 在<strong>创建对象</strong>的时候，只能使用唯一一次，如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。</li>
<li>匿名对象，在<strong>调用方法</strong>的时候，只能调用唯一一次，如果希望多次调用方法，那么必须给对象取个名字</li>
<li>匿名内部类是省略了<strong>实现类/子类名称</strong>，但是匿名对象是省略了<strong>对象名称</strong></li>
</ul>
<p>上述记录于2019.11.1</p>
<h1 id="常用api二">常用API（二）</h1>
<h2 id="object类">Object类</h2>
<p><strong>toString方法：</strong> 返回该对象的字符串表示。 默认打印对象的地址值 直接打印对象的名字，其实就是调用对象的<code>toString</code>方法 判断一个类的<code>toString</code>方法是否被覆盖重写，直接打印对象<code>System.out.println(该对象)</code>，如果得到<strong>地址值</strong>，则没被重写，否则被覆盖重写。 例如：<code>Random</code> 类的<code>toString</code> 没被重写，<code>Scanner</code> 和 <code>ArrayList</code>的被覆盖重写了</p>
<p><strong>equals方法：</strong> 指示其他某个对象是否与此对象“相等” 源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其源码里使用的是<code>==</code> 比较运算符 基本数据类型：比较的是值 引用数据类型：比较的是两个对象的地址值</p>
<p>如果要覆盖重写 <code>equals</code> 方法，要注意的是，由于多态<code>Object</code>是无法使用子类的成员变量的。所以我们需要一个向下转型，将<code>Object</code> 转换成想要的子类。</p>
<p>举一个字符串重写了<code>equals</code>方法的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Equals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"aa"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"aa"</span>);</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// false == 比较的是地址</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// true equals方法被重写，比较的不是地址，而是内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objects类">Objects类</h2>
<blockquote>
<p>JDK7以后添加的一个工具类，它提供了一些方法来操作对象，由一些静态方法组成，这些方法是<code>null-save</code>（空指针安全的）或 <code>null-tolerant</code>（容忍空指针的），用域计算对象的<code>hascode</code> 、返回对象的字符串表现形式、比较两个对象。</p>
</blockquote>
<p><strong>equals方法：</strong> 比较两个对象的时候，<code>Object</code>类的<code>equals</code>方法容易抛出空指针异常，而<code>Objes</code>类中的<code>equals</code>方法就优化了这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects.equals源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line">String s1 = <span class="keyword">null</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//NullPointerException null不能调用方法。抛出空指针异常！</span></span><br><span class="line">System.out.println(Objects.equals(s1,s2)); <span class="comment">// false 根据源码，会事先判断s1是否是空！不会报错</span></span><br></pre></td></tr></table></figure>
<h2 id="date类">Date类</h2>
<p><code>java.util.Date</code>类表示特定的瞬间，精确到毫秒 毫秒值的作用：可以对时间和日期进行计算--把字符串格式的日期转换为毫秒进行计算 时间原点：1970 年 1 月 1 日 00:00:00 GMT （英国格林威治时间） 1000毫秒 = 1秒 中国属于东八区，会把时间增加8个小时</p>
<h2 id="dateformat类">DateFormat类</h2>
<p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类 &gt; 日期/时间格式化子类（如 <code>SimpleDateFormat</code>）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。</p>
<p>成员方法： - <code>String format(Date date)</code> 将一个 <code>Date</code> 格式化为日期/时间字符串。 - <code>Date parse(String source)</code> 从给定字符串的开始解析文本，以生成一个日期。 由于是抽象类所以使用其子类：<code>SimpleDateFormat</code> 它的有参构造需要传入一个字符串类型构造格式，具体构造格式参见API文档，构造格式中的字母有其具体含义不能更改，但是连接字母的符号可以更改。</p>
<p>上述记录于2019.11.4</p>
<h2 id="calendar类">Calendar类</h2>
<p>是一个抽象类，里面提供了很多操作日历字段的方法（<code>YEAR、MONTH、DAY_OF_MONTH、HOUR</code>等）无法直接创建对象，使用下面的静态方法 <code>Calendar rightNow = Calendar.getInstance();</code>使用默认时区和语言环境获得一个日历。（得到的是子类对象 <code>GregorianCalendar</code>， 通过多态用<code>Calendar</code>接收） 其他常用方法参见API文档</p>
<h2 id="system类">System类</h2>
<p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>; <span class="comment">// 返回以毫秒为单位的当前时间 可以用来测试程序得效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>; <span class="comment">// 将数组中指定的数据，拷贝到另一个数组中</span></span><br></pre></td></tr></table></figure>
<p>其他详情方法参见API文档</p>
<h2 id="stringbuilder类">StringBuilder类</h2>
<p><code>String</code>的底层是一个被<code>final</code>修饰的<code>byte</code>数组，不能改变，所以进行字符串的相加时，内存中就会有多个字符串（也就是多个数组），占用空间多，效率低下！ <code>StringBuilder</code>（字符串缓冲区），可以提高字符串的操作效率（看成一个长度可以变化的字符串） 底层也是一个数组，但是没有被<code>final</code>修饰，可以改变长度！ <code>StringBuilder</code>在内存中始终是一个数组（初始容量16）如果超出容量，自动扩容，扩大一倍（32） 两个方法：<code>StringBuilder append(); String toString();</code>详情见API文档</p>
<h1 id="包装类">包装类</h1>
<h2 id="概念">概念</h2>
<p>基本数据类型，使用起来非常方便。但是没有对应的方法，来操作这些基本类型的数据，可以使用一个类把基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类，可以使用类中的方法，来操作这些基本类型的数据。</p>
<table>
<thead>
<tr class="header">
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte</td>
<td>Byte</td>
</tr>
<tr class="even">
<td>short</td>
<td>Short</td>
</tr>
<tr class="odd">
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr class="even">
<td>long</td>
<td>Long</td>
</tr>
<tr class="odd">
<td>float</td>
<td>Float</td>
</tr>
<tr class="even">
<td>double</td>
<td>Double</td>
</tr>
<tr class="odd">
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr class="even">
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<h2 id="装箱与拆箱">装箱与拆箱</h2>
<ul>
<li>装箱：基本类型 --&gt; 包装类对象</li>
<li>拆箱：包装类对象 --&gt; 基本类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day12.demo05;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用Integer举例，演示装箱拆箱过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Integer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装箱1 构造方法</span></span><br><span class="line">        Integer in1 = <span class="keyword">new</span> Integer(<span class="number">1</span>); <span class="comment">// 该方法已经过时</span></span><br><span class="line">        System.out.println(in1); <span class="comment">// 1  作为引用类型，输出的不是地址，说明重写了toString方法</span></span><br><span class="line"></span><br><span class="line">        Integer in2 = <span class="keyword">new</span> Integer(<span class="string">"1"</span>); <span class="comment">//传字符串参数时，要求该字符串可以变成int的才行。比如传"a"就会抛出数字格式化异常 NumberFormatException</span></span><br><span class="line">        System.out.println(in2); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//装箱2 静态方法</span></span><br><span class="line">        Integer in3 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">        System.out.println(in3); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        Integer in4 = Integer.valueOf(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(in4); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆箱</span></span><br><span class="line">        <span class="keyword">int</span> in5 = in1.intValue();</span><br><span class="line">        System.out.println(in5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动拆箱与自动装箱">自动拆箱与自动装箱</h2>
<p>JDK1.5之后:基本类型的数据和包装类之间可以自动相互转换 <strong>包装类无法直接参与运算，但是可以自动转换为基本数据类型，再进行计算</strong> ps：那我他妈的上面白写了???</p>
<h2 id="基本类型与字符串之间的相互转换">基本类型与字符串之间的相互转换</h2>
<p><strong>基本类型 --&gt; 字符串</strong> 1. <code>基本类型的值+""(空字符串)</code> 最简单方法 2. 包装类的静态方法 <code>toString(参数)</code>,不是 <code>Object</code> 类的 <code>toString()</code> ,后者是空参数，所以二者是方法重载的关系 3. <code>String</code> 类的静态方法 <code>valueOf(参数)</code></p>
<p><strong>字符串 --&gt; 基本类型</strong> 包装类的静态方法 <code>parseXXX("数值类型的字符串")</code></p>
<h1 id="单列集合collection">单列集合Collection</h1>
<h2 id="集合概述">集合概述</h2>
<p>集合是java中提供的一种容器，可以用来存储多个数据。</p>
<p><strong>集合和数组的区别: </strong> 1. 数组的长度是固定的。集合的长度是可变的。 2. 数组中存储的是<strong>同一数据类型（基本or引用）</strong>的元素；集合存储的都是<strong>对象（基本类型自动装箱）</strong>，而且<strong>对象的类型可以不一致</strong>。在开发中一般当对象多的时候，使用集合进行存储。</p>
<h2 id="collection集合框架">Collection集合框架</h2>
<figure>
<img src="\image\16.2.png" alt="" /><figcaption>16.2</figcaption>
</figure>
<h2 id="两种单列集合">两种单列集合：</h2>
<ul>
<li><strong>List 接口</strong></li>
</ul>
<ol type="1">
<li>有序的集合（存储和取出元素顺序相同）</li>
<li>允许存储重复的元素</li>
<li>有索引，可以使用普通的for循环遍历</li>
</ol>
<ul>
<li><strong>Set 接口</strong></li>
</ul>
<ol type="1">
<li>不允许存储重复元素</li>
<li>没有索引（不能使用普通的for循环遍历）</li>
<li>子类TreeSet是无序集合</li>
<li>子类HashSet是有序集合</li>
</ol>
<h2 id="collection-共性方法-常用功能">Collection 共性方法 常用功能</h2>
<p><code>java.util.Collection</code> 是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>： 把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。注意：List接口覆盖重写了此方法！（因为List都有索引，所以重写成了删除索引位置元素）</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>上述记录于2019.11.5</p>
<h1 id="iterator-接口">Iterator 接口</h1>
<h2 id="迭代器功能介绍">迭代器功能介绍</h2>
<p>每种集合的存取方式不同，需要一种通用的获取集合的方式----迭代。 <code>Iterator</code> 迭代器是一个接口，无法直接使用，需要使用其实现类，获取实现类的方式比较特殊：<code>Collection</code> 接口中有一个方法，<code>iterator()</code>返回的就是迭代器的实现类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用步骤：</span></span><br><span class="line"><span class="comment">1. 使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</span></span><br><span class="line"><span class="comment">2. 使用迭代器中的方法hasNext判断还有没有下一个元素</span></span><br><span class="line"><span class="comment">3. 使用迭代器中的方法next取出集合中的下一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">"伍陆柒"</span>);</span><br><span class="line">        coll.add(<span class="string">"鸡大宝"</span>);</span><br><span class="line">        coll.add(<span class="string">"小飞"</span>);</span><br><span class="line">        coll.add(<span class="string">"梅十三"</span>);</span><br><span class="line">        coll.add(<span class="string">"江主任"</span>);</span><br><span class="line">        <span class="comment">// Iterator&lt;E&gt; 接口的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator(); <span class="comment">// 多态</span></span><br><span class="line">        <span class="keyword">boolean</span> b = it.hasNext();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        String s = it.next(); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s); <span class="comment">// 伍陆柒</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果集合中没有元素，再调用next取出元素，会抛出NoSuchElementException（没有元素异常)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 使用while循环</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            String e = it.next();</span><br><span class="line">            System.out.print(<span class="string">" "</span> + e + <span class="string">" "</span>); <span class="comment">// 鸡大宝  小飞  梅十三  江主任</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 使用for循环</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it2 =coll.iterator(); it2.hasNext();) &#123;</span><br><span class="line">            String e = it2.next();</span><br><span class="line">            System.out.print(<span class="string">" "</span> + e + <span class="string">" "</span>); <span class="comment">// 伍陆柒  鸡大宝  小飞  梅十三  江主任</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增强for循环">增强for循环</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写</span></span><br><span class="line"><span class="comment">是JDK1.5之后出现的新特性 Collection&lt;E&gt; extends Iterable&lt;E&gt;</span></span><br><span class="line"><span class="comment">Interable&lt;T&gt; 实现这个接口允许对象成为"foreach"语句的目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Foreach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用增强for循环遍历集合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        list.add(<span class="string">"ccc"</span>);</span><br><span class="line">        list.add(<span class="string">"ddd"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用增强for循环遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型">泛型</h1>
<h2 id="概念-1">概念</h2>
<p>是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型 泛型也可以看成是一个变量，用来接收数据类型 <code>Ee: Element</code> 元素 <code>Tt: Type</code> 类型 <code>ArrayList</code>集合在定义的时候：<code>public class ArrayList&lt;E&gt;{...}</code>，不知道集合中都会存储什么类型的数据，所以类型使用泛型<code>E</code> <strong>创建对象的时候，就会确定泛型的数据类型</strong> <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code>会把数据类型作为参数传递，赋值给泛型 <code>E</code> 。此时 <code>E</code> 被确定为 <code>String</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01(); <span class="comment">// 报错！</span></span><br><span class="line">        show02();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建集合对象， 不使用泛型</span></span><br><span class="line"><span class="comment">    好处：</span></span><br><span class="line"><span class="comment">        集合默认类型就是Object类型，可以存储任意类型的数据</span></span><br><span class="line"><span class="comment">    坏处：</span></span><br><span class="line"><span class="comment">        不安全，会引发异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 没有写&lt;&gt; 不写就是默认Object</span></span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="comment">// 获取迭代器 迭代器泛型跟着集合走，集合默认，迭代器也默认Object</span></span><br><span class="line">        Iterator it = list.iterator();</span><br><span class="line">        <span class="comment">// 使用hasnext 与next</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Object obj = it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 想要 使用 String类特有方法，length， 但因为是多态，不能使用子类特有方法，所以需要向下转型</span></span><br><span class="line">            <span class="comment">// 会抛出ClassCastException 类型转换异常，Integer不能转换为String</span></span><br><span class="line">            String s = (String)obj;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建集合对象，使用泛型</span></span><br><span class="line"><span class="comment">    好处：</span></span><br><span class="line"><span class="comment">    1. 避免了类型转换的麻烦</span></span><br><span class="line"><span class="comment">    2. 把运行期异常，提升到了编译期</span></span><br><span class="line"><span class="comment">    坏处：</span></span><br><span class="line"><span class="comment">    泛型是什么类型，就只能存储什么类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">//        list.add(1)； 编译的时候就会报错</span></span><br><span class="line">        <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s + s.length()); <span class="comment">// 不需要使用类型转换，直接调用String特有的length方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义和使用含有泛型的类">定义和使用含有泛型的类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个含有泛型的类，可以模拟ArrayList集合</span></span><br><span class="line"><span class="comment">泛型是一个未知的数据类型，当我们不确定使用什么数据类型的时候，可以使用泛型</span></span><br><span class="line"><span class="comment">泛型可以接收任意的数据类型，可以使用Integer.String.自定义类...</span></span><br><span class="line"><span class="comment">创建对象的时候确定泛型的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02GenericClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不写泛型，默认Object</span></span><br><span class="line">        GenericClass gc = <span class="keyword">new</span> GenericClass();</span><br><span class="line">        gc.setName(<span class="string">"默认Object类，什么数据类型都可以"</span>);</span><br><span class="line">        Object obj = gc.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象，泛型Integer</span></span><br><span class="line">        GenericClass&lt;Integer&gt; gc2 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc2.setName(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Integer name = gc2.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象，泛型String</span></span><br><span class="line">        GenericClass&lt;String&gt; gc3 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc3.setName(<span class="string">"伍陆柒"</span>);</span><br><span class="line">        String name1 = gc3.getName();</span><br><span class="line">        System.out.println(name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="含有泛型的方法">含有泛型的方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义含有泛型的方法，泛型定义在方法的修饰符和返回值类型之间</span></span><br><span class="line"><span class="comment">在调用方法的时候，确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个含有泛型的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个含有泛型的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个GenericMethod对象</span></span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用含有泛型的方法method01</span></span><br><span class="line"><span class="comment">        传递什么类型，泛型就是什么类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gm.method01(<span class="number">10</span>);</span><br><span class="line">        gm.method01(<span class="string">"abc"</span>);</span><br><span class="line">        gm.method01(<span class="number">8.8</span>);</span><br><span class="line">        gm.method01(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态泛型方法</span></span><br><span class="line">        gm.method02(<span class="string">"静态方法，不建议创建对象使用"</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="含有泛型的接口">含有泛型的接口</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义含有泛型的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 含有泛型的接口，第一种使用方式：定义接口的实现类，实现接口，指定接口的泛型（迭代器接口就是有泛型的 Scanner就是其实现类）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 含有泛型的接口第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span></span><br><span class="line"><span class="comment">* 就相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型（例如ArrayList是List的实现类）*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试含有泛型的接口</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建GenericInterfaceImpl1对象</span></span><br><span class="line">        GenericInterfaceImpl1 gil1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        gil1.method(<span class="string">"字符串"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建GenericInterfaceImpl2对象</span></span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; gil2 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gil2.method(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        GenericInterfaceImpl2&lt;Double&gt; gil3 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        System.out.println(<span class="number">8.8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型通配符">泛型通配符</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 泛型的通配符：&lt;?&gt; 代表任意的数据类型</span></span><br><span class="line"><span class="comment">* 不能创建对象使用，只能作为方法的参数使用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ArrayList&lt;?&gt; list = new ArrayList&lt;?&gt;(); 报错，不能在创建对象时使用！</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="string">"a"</span>);</span><br><span class="line">        list02.add(<span class="string">"b"</span>);</span><br><span class="line">        printArray(list01);</span><br><span class="line">        printArray(list02);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个方法，能遍历所有类型的ArrayList集合</span></span><br><span class="line"><span class="comment">     * 泛型没有继承的概念！</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//取出元素是Object，只有它可以接收任意的类型</span></span><br><span class="line">            Object obj = it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>泛型的上限限定：</strong> <code>? extends E</code> 代表使用的泛型只能是E类型的子类/本身 <strong>泛型的下限限定：</strong> <code>? super E</code> 代表使用的泛型只能是E类型的父类/本身 平时用的不多</p>
<h1 id="数据结构">数据结构</h1>
<p><strong>本模块只介绍与集合相关的部分，更多内容请另看《数据结构》</strong></p>
<p><strong>栈</strong> LIFO 后进先出</p>
<p><strong>队列</strong> FIFO 先进先出</p>
<p><strong>数组</strong> 查询快（数组地址连续，通过首地址找到数组，通过索引快速找到某一个元素） 增删慢（数组长度固定，想要增加或者删除元素，必须创建一个新数组。把原数组复制过来，垃圾回收原数组）</p>
<p><strong>链表</strong> <strong>与数组相反：</strong> 查询慢（链表地址不连续，每次查询元素，必须从头开始查询） 增删快（链表接口增加/删除元素，对链表的整体结构（指针域和数据域）没有影响，只需要改变指针）</p>
<p><strong>红黑树：</strong> 趋近于平衡树（左右叶子节点相等） 查询速度非常快 查询叶子节点最大次数和最小次数不能超过2倍（换句话说 就是趋近于平衡树的不平衡树） 约束规则： 1.节点可以是红色的或者黑色的 2.根节点是黑色的 3.叶子节点（空节点）是黑色的 4.每个红色的节点的子节点都是黑色的 5.任何一个节点到其每一个叶子节点的所有路径上的黑色节点数相同</p>
<h1 id="接口list">接口List</h1>
<p>有序、有索引（注意索引越界异常）、允许存储重复的元素</p>
<p><strong>ArrayList</strong> 本质是一个数组结构，查找快、增删慢。（其中的add方法调用的copyof） 上文使用的ArrayList就实现了List接口，这里就不过多赘述了。 不同步 速度快</p>
<p><strong>LinkedList</strong> 本质是链表结构，查询慢，增删快。 里面包含了大量操作首尾元素的特有方法（属于其特有的，不能通过多态调用） 不同步</p>
<p><strong>Vector</strong> 所有单列集合的祖宗，底层也是数组 同步 速度慢 了解即可</p>
<p>上述记录于2019.11.6</p>
<h1 id="接口set">接口Set</h1>
<p>不允许存储重复元素、没有索引 因此没有带索引的方法，不能用普通 <code>for</code> 循环遍历，里面方法和 <code>Collection</code> 方法一致，不过多赘述，毕竟 <code>Collection</code> 是他的父接口啊。。。。</p>
<h2 id="hashset">HashSet</h2>
<p><code>java.util.HashSet</code>实现了<code>Set</code> 接口，是一个无序的集合（存储元素和取出元素的顺序有可能不一致），重复元素只存一次；底层是一个哈希表结构（查询的速度非常的快）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Set</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用add 往集合中添加元素</span></span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 没有索引，不能用普通for循环 ，用迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            Integer n = it.next();</span><br><span class="line">            System.out.println(n); <span class="comment">// 1 2 3 存储的顺序和取出的顺序可能不一样，而且不存储重复的元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希值">哈希值</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的得到的地址，不是数据实际存储的物理地址，不是 == 运算符比较的那个地址！）</span></span><br><span class="line"><span class="comment">* 在Object类有一个方法，可以获取对象的哈希值</span></span><br><span class="line"><span class="comment">* 方法源码：</span></span><br><span class="line"><span class="comment">* public native int hashCode();</span></span><br><span class="line"><span class="comment">* native：代表该方法调用的是本地操作系统的方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01HashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 =  <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> h1 = p1.hashCode();</span><br><span class="line">        System.out.println(h1); <span class="comment">// 10进制整数 系统随机给定</span></span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> h2 = p2.hashCode();</span><br><span class="line">        System.out.println(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//toString 方法输出的就是哈希值的十六进制形式</span></span><br><span class="line">        System.out.println(p1);  <span class="comment">// h1 的16进制形式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// String类重写了Object类的hashCode方法</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1.hashCode()); <span class="comment">// 96354 重写了的</span></span><br><span class="line">        System.out.println(s2.hashCode()); <span class="comment">// 96354</span></span><br><span class="line">        System.out.println(<span class="string">"重地"</span>.hashCode()); <span class="comment">// 1179395</span></span><br><span class="line">        System.out.println(<span class="string">"通话"</span>.hashCode()); <span class="comment">// 1179395 两个元素不同 但哈希值相同，哈希冲突。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表">哈希表</h2>
<p>哈希表是 <code>HashSet</code> 的存储结构 JDK1.8之前 <code>哈希表 = 数组+链表</code> JDK1.8之后 <code>哈希表 = 数组+链表</code>如果链表长度超过8位:<code>哈希表 = 数组+红黑树</code>（提高查询的速度） 数组里存<code>hashCode</code> ，链表/树里存元素</p>
<h2 id="set集合不允许重复元素">Set集合不允许重复元素</h2>
<p><code>Set</code>集合在调用<code>add</code>方法的时候，<code>add</code>会调用元素的<code>hashCode</code>方法和<code>equals</code>方法，判断元素是否重复。<code>hashCode</code>相同时，调用<code>equals</code>看两个元素是否<strong>相等（此处的相等不一样的类型有不一样的意思，比如字符串相等是指两个字符串的字符是一样的，所以你自定义的类型相等是要看你自己怎么定义，所以要重写equals）</strong>。因此如果要用<code>Set</code>存储自定义类型元素的话，必须重写<code>hashCode</code>方法和<code>equals</code>方法。</p>
<h2 id="hashset存储自定义类型元素">HashSet存储自定义类型元素</h2>
<p><strong>必须重写HashCode和equals方法 保证元素不重复！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同名和同年龄的人视为同一人，只出现一次！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetSavePerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"伍陆柒"</span>,<span class="number">25</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"伍陆柒"</span>,<span class="number">25</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"伍陆柒"</span>,<span class="number">24</span>);</span><br><span class="line">        System.out.println(p1.hashCode()); <span class="comment">// 640675041</span></span><br><span class="line">        System.out.println(p2.hashCode()); <span class="comment">//640675041 重写hashCode 返回的哈希值相等</span></span><br><span class="line"></span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">// false 地址不同 是两个对象</span></span><br><span class="line">        System.out.println(p1.equals(p2)); <span class="comment">// true 重写equals 同名同年龄返回true</span></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line">        System.out.println(set); <span class="comment">// [Person&#123;name='伍陆柒', age=25&#125;, Person&#123;name='伍陆柒', age=24&#125;] 同名同年龄的只出现一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="linkedhashset">LinkedHashSet</h2>
<p><code>HashSet</code>的子类 是有序的！ 底层是一个哈希表+链表（用来记录元素的存储顺序，保证元素有序）</p>
<h2 id="可变参数">可变参数</h2>
<p>在JDK1.5以后，如果我们定义一个方法需要接收多个参数，并且多个参数类型一致，我们可以对其简化成如下格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原理：</strong> 可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数 传递的参数个数，可以是0个（不传递），1， 2...多个。 传递几个参数，数组的长度就是几。</p>
<p><strong>注意事项：</strong> 1. 一个方法的参数列表，只能有一个可变参数 2. 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</p>
<p>可变参数的终极写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(Object... 形参名)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="collections类">Collections类</h1>
<p>集合工具类，用来对集合进行操作</p>
<p><strong>常用静态方法：</strong> 1. <code>addAll</code>一次性添加多个元素、 2. <code>shuffle</code>打乱集合顺序、 3. <code>sort</code>排序（只能传List集合参数，默认升序，对于自定义类，需要实现Comparable接口，覆盖重写compareTo(参数)方法才能使用sort） <code>Comparable</code>接口的排序规则：<code>自己(this)-参数</code> 升序， 反之降序。 4. <code>sort(ListM&lt;T&gt; list, Comparator&lt;? super T&gt;)</code>按照给定规则进行排序 <code>Comparator</code> 是一个接口，里面有<code>compare(o1, o2)</code>方法，需要覆盖重写 <code>Comparator</code>接口的排序规则：<code>o1-o2</code> 升序，反之降序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo07;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖重写compareTo方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day13.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"baobo"</span>, <span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"baobo"</span>, <span class="number">20</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"andelu"</span>, <span class="number">18</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">"caibi"</span>, <span class="number">15</span>);</span><br><span class="line">        Collections.addAll(list, p1, p2, p3, p4); <span class="comment">// 初始顺序</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//[Person&#123;name='baobo', age=18&#125;, Person&#123;name='baobo', age=20&#125;, Person&#123;name='andelu', age=18&#125;, Person&#123;name='caibi', age=15&#125;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort方法1</span></span><br><span class="line">        Collections.sort(list); <span class="comment">// 需要list实现Comparable接口。覆盖重写compareTo方法</span></span><br><span class="line">        System.out.println(list);<span class="comment">// 按照年龄升序排序</span></span><br><span class="line">        <span class="comment">//[Person&#123;name='caibi', age=15&#125;, Person&#123;name='baobo', age=18&#125;, Person&#123;name='andelu', age=18&#125;, Person&#123;name='baobo', age=20&#125;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort方法2</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123; <span class="comment">// 使用Comparator的匿名类 构造了一个Comparator的实现类（多态）</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123; <span class="comment">// 重写compare方法</span></span><br><span class="line">                <span class="keyword">int</span> result = o1.getAge() - o2.getAge();</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>) - o2.getName().charAt(<span class="number">0</span>); <span class="comment">// 如果年龄相等，比较名字的首字母大小</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list); <span class="comment">// 年龄相等时，按照首字母排序</span></span><br><span class="line">        <span class="comment">// [Person&#123;name='caibi', age=15&#125;, Person&#123;name='andelu', age=18&#125;, Person&#123;name='baobo', age=18&#125;, Person&#123;name='baobo', age=20&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.11.7</p>
<h1 id="双列集合map">双列集合Map</h1>
<p><strong>Map特点：</strong></p>
<ol type="1">
<li>不同于<code>Collection</code> ，<code>Map&lt;K,V&gt;</code>集合是一个<strong>双列集合</strong>，一个元素包含两个值（一个key，一个value）</li>
<li>key和value的数据类型可以相同，也可以不同</li>
<li>key是不允许重复的，value是可以重复的</li>
<li>key和value是一一对应的</li>
</ol>
<h2 id="hashmap">HashMap</h2>
<p><code>java.util.HashMap</code> 实现Map接口。 底层和<code>HashSet</code> 一样是哈希表结构（查询速度非常快），无序 不同步（多线程 速度快）</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<p>HashMap的子类，底层是哈希表+链表。类似LinkedHashSet，有序（因为加了链表）</p>
<h2 id="map常用方法">Map常用方法</h2>
<p>Map接口中定义了很多方法，常用的如下： - <code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。若<code>key</code>不存在，返回值为<code>null</code>；否则，返回参数<code>value</code></p>
<blockquote>
<p>key不存在时，返回的是value的默认值，因为value是T类型，也就是引用类型，引用类型的默认值就是null</p>
</blockquote>
<ul>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。若<code>key</code>存在，返回<code>key</code>对应的<code>value</code>；否则，返回<code>null</code></li>
<li><code>public V get(Object key)</code> 根据指定的<code>key</code>键，在Map集合中获取对应的<code>value</code>值。</li>
<li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day14.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Map集合特点：</span></span><br><span class="line"><span class="comment"> *   1. Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）</span></span><br><span class="line"><span class="comment"> *   2. key和value的数据类型可以相同，也可以不同</span></span><br><span class="line"><span class="comment"> *   3. key是不允许重复的，value是可以重复的</span></span><br><span class="line"><span class="comment"> *   4. key和value是一一对应的*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 多态</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String v1 = map.put(<span class="string">"伍陆柒"</span>, <span class="string">"可乐"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1： "</span> + v1); <span class="comment">// null key不重复 返回空</span></span><br><span class="line">        String v2 = map.put(<span class="string">"伍陆柒"</span>, <span class="string">"梅十三"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1： "</span> + v2); <span class="comment">// 可乐 key重复 返回被替换的值</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.put(<span class="string">"阿珍"</span>,<span class="string">"阿强"</span>);</span><br><span class="line">        map.put(<span class="string">"汪峰"</span>,<span class="string">"咪咪"</span>);</span><br><span class="line">        map.put(<span class="string">"喵财"</span>,<span class="string">"咪咪"</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;伍陆柒=梅十三, 喵财=咪咪, 汪峰=咪咪, 阿珍=阿强&#125; 无序，不一定按照输入的顺序输出</span></span><br><span class="line">        <span class="comment">// key 不能重复，但是value可以重复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day14.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"可乐"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"江主任"</span>,<span class="number">178</span>);</span><br><span class="line">        map.put(<span class="string">"梅十三"</span>,<span class="number">168</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;可乐=165, 梅十三=168, 江主任=178&#125;</span></span><br><span class="line">        Integer v1 = map.remove(<span class="string">"江主任"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1: "</span> + v1); <span class="comment">// 178 删除的key对应的value</span></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;可乐=165, 梅十三=168&#125;</span></span><br><span class="line">        Integer v2 = map.remove(<span class="string">"伍陆柒"</span>); <span class="comment">// 使用包装类接收，因为有可能是null 基本数据类型int没有null</span></span><br><span class="line">        System.out.println(<span class="string">"v2"</span> + v2); <span class="comment">// null 没有找到此key </span></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;可乐=165, 梅十三=168&#125;</span></span><br><span class="line">    </span><br><span class="line">        Integer v3 = map.get(<span class="string">"可乐"</span>);</span><br><span class="line">        Integer v4 = map.get(<span class="string">"伍陆柒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v3 和 v4 分别是： "</span> + v3 + <span class="string">" "</span> + v4); <span class="comment">// 165 null</span></span><br><span class="line">        <span class="keyword">boolean</span> b1 = map.containsKey(<span class="string">"可乐"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b2 = map.containsKey(<span class="string">"伍陆柒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1 和 b2 分别是： "</span> + b1 + <span class="string">" "</span> + b2); <span class="comment">// true false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历map集合">遍历Map集合</h2>
<p>遍历方法: 1. <code>keySet</code> ： 把<code>Map</code>集合中所有的<code>key</code>取出来存储到<code>Set</code>集合中，这样就可以通过遍历<code>Set</code>遍历<code>key</code>，通过<code>get</code>方法遍历<code>value</code>。 2. <code>entrySet</code>： 把<code>Map</code>集合内部得多个<code>Entry</code>对象取出来，存储到一个<code>Set</code>集合中，遍历<code>Set</code>集合，获取<code>Set</code>集合中的每一个<code>Entry</code>对象。再使用<code>Entry</code>对象中的方法<code>getKey</code>和<code>getValue</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"老板"</span>, <span class="string">"绯红之王"</span>);</span><br><span class="line">        map.put(<span class="string">"吉良吉影"</span>, <span class="string">"杀手皇后"</span>);</span><br><span class="line">        map.put(<span class="string">"DIO"</span>, <span class="string">"The World!"</span>);</span><br><span class="line">        map.put(<span class="string">"JOJO"</span>, <span class="string">"Gold Experience"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keySet方法遍历</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            <span class="comment">// key与value之间的链接符可以随意更改</span></span><br><span class="line">            System.out.println(key + <span class="string">"--"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*老板--绯红之王</span></span><br><span class="line"><span class="comment">          JOJO--Gold Experience</span></span><br><span class="line"><span class="comment">          吉良吉影--杀手皇后</span></span><br><span class="line"><span class="comment">          DIO--The World!*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// entrySet方法遍历</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            <span class="comment">// key与value作为一个整体输出，之间的链接符默认为=</span></span><br><span class="line">            System.out.println(entry);</span><br><span class="line">          	<span class="comment">// 也可以分别用Entry对象的方法 输出key和value，这样链接符可以随意更改</span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*老板=绯红之王</span></span><br><span class="line"><span class="comment">          JOJO=Gold Experience</span></span><br><span class="line"><span class="comment">          吉良吉影=杀手皇后</span></span><br><span class="line"><span class="comment">          DIO=The World!*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entry键值对对象">Entry键值对对象</h2>
<p><code>Entry</code> 是 <code>Map</code> 的嵌套类（<strong>内部类</strong>） 作用：当<code>Map</code>集合一创建，就会在<code>Map</code>集合中创建一个<code>Entry</code>对象，用来记录键与值（键值对对象，键与值的关系）</p>
<h2 id="hashmap存储自定义类型键值">HashMap存储自定义类型键值</h2>
<p>类似 <strong>31.5 HashSet存储自定义类型元素</strong> 为了保证<code>key</code>值唯一，作为<code>key</code>元素的类型，必须覆盖重写<code>hashCode</code>方法和<code>equals</code>方法！</p>
<h2 id="linkedhashmap-1">LinkedHashMap</h2>
<p>继承了<code>HashMap</code>集合 底层原理：哈希表+链表结构（记录元素的顺序）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day14.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01LinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"a"</span>, <span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</span><br><span class="line">        map.put(<span class="string">"a"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;a=d, b=b, c=c&#125; 不允许重复，无序</span></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        linkedHashMap.put(<span class="string">"a"</span>, <span class="string">"a"</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"a"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(linkedHashMap); <span class="comment">// &#123;a=d, c=c, b=b&#125; 有序 同样不允许重复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashtable">HashTable</h2>
<p><code>JDK1.0</code>就有了，最早期的集合 底层也是哈希表 键与值都不允许存储<code>null</code>（之前学的所有集合都可以），同步 线程安全 单线程，速度慢 和<code>Vector</code>一样，都被1.2版本之后的<code>HashMap</code>取代了 但是其子类<code>Properties</code>依然活跃 ，<code>Properties</code>是唯一一个和<code>IO</code>流相结合的集合</p>
<h1 id="jdk9优化">JDK9优化</h1>
<p><code>Set Map List</code> 三个接口中都定义了新的方法 <code>of</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day14.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* JDK9的新特性：</span></span><br><span class="line"><span class="comment">*   List、Set、Map接口里面增加了一个静态的方法of，可以一次性添加多个元素</span></span><br><span class="line"><span class="comment">*   前提：</span></span><br><span class="line"><span class="comment">*          当集合中存储的元素的个数已经确定了，不再改变时使用</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*           1. of方法只适用于List接口、Set接口、Map接口，不适用于接口的实现类</span></span><br><span class="line"><span class="comment">*           2. of方法的返回值是一个不能改变的集合，集合不能再使用add或者是put方法添加元素</span></span><br><span class="line"><span class="comment">*           3. Set和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01JDK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [a, b, a, c, d]</span></span><br><span class="line"><span class="comment">//        list.add("w");  报错 UnsupportedOperationException 不支持操作异常</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = Set.of("a", "b", "a", "c", "d"); 报错 有重复的参数 IllegalArgumentException 非法参数异常</span></span><br><span class="line">        Set&lt;String&gt; set = Set.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">// [a, c, b, d]</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = Map.of(<span class="string">"伍陆柒"</span>, <span class="number">25</span>, <span class="string">"梅十三"</span>, <span class="number">23</span>, <span class="string">"鸡大宝"</span>, <span class="number">28</span>);<span class="comment">// 也不能重复</span></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;梅十三=23, 鸡大宝=28, 伍陆柒=25&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="debug追踪">Debug追踪</h1>
<p>可以让代码逐行执行，查看代码的过程，调式程序中出现的bug</p>
<p><strong>使用方式：</strong> 1. 在行号的右边，鼠标左键单击，添加断点（初学时添加在每个方法的第一行，熟练了之后 哪里有bug添加到哪里） 2. 右键，选择Debug执行程序 3. 程序就会停留在添加的第一个断点处</p>
<p><strong>执行程序：</strong> <code>f8</code>：逐行执行程序 <code>f7</code>：进入到方法中 <code>shift+f8</code>：跳出方法 <code>f9</code>：跳到下一个断点，如果没有下一个断点，那么就结束程序 <code>ctrl+f2</code>：退出debug模式，停止程序 <code>Console</code>：切换到控制台</p>
<p>上述记录于2019.11.8</p>
<h1 id="异常">异常</h1>
<h2 id="异常的概念">异常的概念</h2>
<p>异常指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出一个异常对象。<strong>Java处理异常的方式是中断处理。</strong> <strong>异常</strong>指的并不是<strong>语法错误</strong>，语法错了，编译不通过，不会产生字节码文件，根本不能运行！</p>
<h2 id="异常的体系">异常的体系</h2>
<p>异常的根类<code>java.lang.Throwable</code> 其下有两个子类：<code>java.lang.Error</code> 与 <code>java.lang.Exception</code></p>
<ul>
<li><code>Error</code>是<strong>错误</strong>：错误就相当于程序得了一个无法治愈的病，必须修改源代码，程序才能继续执行。</li>
<li><code>Exception</code> 是<strong>编译期异常</strong>，进行编译（写代码）时Java程序出现的问题。这种异常在写代码的时候编译器就会指出来。例如：<code>java.io.IOException</code>
<ul>
<li>其子类 <code>RuntimeException:</code> 是<strong>运行期异常</strong>，java程序运行过程中出现的问题。这种异常在写代码的时候编译器不会指出来，但是如果不处理的话，编译运行的时候会产生异常对象，并且默认向上抛出，直到抛给<code>JVM</code>，Java虚拟机的处理方式是：打印异常信息、终止当前正在执行的Java程序。（看不懂这段话没关系，看完下面的图，再回来看就理解了。）</li>
<li>异常就相当于程序得了一个小毛病，把异常处理掉，程序可以继续执行。</li>
</ul></li>
<li><strong>简而言之：编译期异常必须处理，使用try...catch或throws；运行期异常可不处理，默认交给JVM处理</strong></li>
</ul>
<h2 id="异常产生过程的解析">异常产生过程的解析</h2>
<p>分析异常是怎么产生的，如何处理异常</p>
<p><img src="\image\36.3_异常的产生过程解析.bmp" /></p>
<h2 id="异常的处理">异常的处理</h2>
<p>五个关键字<strong>try catch finally throw throws</strong></p>
<p><strong>抛出异常 throw</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* throw 关键字</span></span><br><span class="line"><span class="comment">* 作用：</span></span><br><span class="line"><span class="comment">*   可以使用throw关键字在指定的方法中抛出指定的异常</span></span><br><span class="line"><span class="comment">* 使用格式：</span></span><br><span class="line"><span class="comment">*   throw new xxxException("异常产生的原因")</span></span><br><span class="line"><span class="comment">* 注意：</span></span><br><span class="line"><span class="comment">*   1. throw关键字必须写在方法的内部</span></span><br><span class="line"><span class="comment">*   2. throw关键字后边new的对象必须是Exception或者Exception的子类对象</span></span><br><span class="line"><span class="comment">*   3. throw关键字抛出指定的异常对象，我们就必须处理这个异常对象</span></span><br><span class="line"><span class="comment">*       throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）</span></span><br><span class="line"><span class="comment">*       throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try...catch</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Throw</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*        int[] arr = null;</span></span><br><span class="line"><span class="comment">        int e = getElement(arr, 0);</span></span><br><span class="line"><span class="comment">        System.out.println(e);*/</span> <span class="comment">// Exception in thread "main" java.lang.NullPointerException: 传递的数组值为null</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> e1 = getElement(arr1, <span class="number">3</span>); <span class="comment">// Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 数组的索引越界了</span></span><br><span class="line">        System.out.println(e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 以后工作中，必须对方法传递过来的参数进行合法性校验</span></span><br><span class="line"><span class="comment">    * 如果参数不合法，那么就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"传递的数组值为null"</span>); <span class="comment">// NullPointerException是一个运行期异常，我们不用处理，默认交给JVM处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组的索引越界了"</span>); <span class="comment">// ArrayIndexOutOfBoundsException也是运行期异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ele = arr[index];</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Objects非空判断</strong></p>
<p>之前提到过Objects类提供一些静态方法，这些方法是空指针安全的或容忍空指针的，因为它对对象为null的值进行了抛出异常操作。 <code>public static &lt;T&gt; T requireNonNull(T obj)</code>: 查看指定引用对象是不是null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>throws关键字 异常处理的第一种方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* throws关键字：异常处理的第一种方式，交给别人处理</span></span><br><span class="line"><span class="comment">* 作用：</span></span><br><span class="line"><span class="comment">*   当方法内部抛出异常对象的时候，那么我们必须处理这个异常对象</span></span><br><span class="line"><span class="comment">*   可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终交给JVM处理 --&gt; 中断处理</span></span><br><span class="line"><span class="comment">* 使用格式：在方法声明时使用</span></span><br><span class="line"><span class="comment">*   修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException...&#123;</span></span><br><span class="line"><span class="comment">*       throw new AAAException("异常产生的原因");</span></span><br><span class="line"><span class="comment">*       throw new BBBException("异常产生的原因");</span></span><br><span class="line"><span class="comment">*       ...</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* 注意：</span></span><br><span class="line"><span class="comment">*   1. throws关键字必须写在方法声明处</span></span><br><span class="line"><span class="comment">*   2. throws关键字后面声明的异常必须是Exception或者是Exception的子类</span></span><br><span class="line"><span class="comment">*   3. 方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常</span></span><br><span class="line"><span class="comment">*       如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可</span></span><br><span class="line"><span class="comment">*   4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常</span></span><br><span class="line"><span class="comment">*       要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM</span></span><br><span class="line"><span class="comment">*       要么try... catch自己处理异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Throws</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="comment">// 继续声明，交给JVM处理</span></span><br><span class="line">        readFile(<span class="string">"c:\\a.pdf"</span>); <span class="comment">// Exception in thread "main" java.io.IOException: 文件的后缀名不对 JVM 处理一个异常便会终止程序，不会处理后续代码了。但是try catch可以！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="comment">// FileNotFoundException 是 IOException 的子类，只抛出父类即可</span></span><br><span class="line">        <span class="keyword">if</span> (!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fileName.equals(<span class="string">"c:\\a.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件路径不是c:\\a.txt"</span>); <span class="comment">// FileNotFoundException 是编译异常，抛出了编译异常，就必须处理这个异常，可以使用throws 继续声明抛出FileNotFoundException 这个异常对象，让方法的调用者处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"路径没有问题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>try... catch关键字 异常处理的第二种方式</strong></p>
<p><strong>各人见解：</strong> <code>try..catch</code>比 <code>throws</code> 好的地方在于，<code>throws</code> 如果一直向上抛出，抛给虚拟机之后，虚拟机会直接终止程序运行，而有时候我们遇到异常，并不希望整个程序停止，利用<code>try...catch</code>我们可以合理的控制异常的大小，什么样的异常需要终止程序，什么样的异常可以忽略，什么样的异常可以做一些特殊的操作。比<code>throws</code>灵活很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* try...catch: 异常处理的第二种方式，自己处理异常</span></span><br><span class="line"><span class="comment">* 格式：</span></span><br><span class="line"><span class="comment">*   try &#123;</span></span><br><span class="line"><span class="comment">*       可能产生异常的代码</span></span><br><span class="line"><span class="comment">*   &#125;catch(定义一个异常的变量，用来接收try中抛出的异常对象)&#123;</span></span><br><span class="line"><span class="comment">*       异常的处理逻辑，产生异常对象之后，怎么处理异常对象</span></span><br><span class="line"><span class="comment">*       一般在工作中，会把异常的信息记录到一个日志中</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*   ...</span></span><br><span class="line"><span class="comment">*   catch(异常类名 变量名)&#123;</span></span><br><span class="line"><span class="comment">*       catch可以有多个</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* 注意：</span></span><br><span class="line"><span class="comment">*   1. try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象</span></span><br><span class="line"><span class="comment">*   2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码</span></span><br><span class="line"><span class="comment">*       如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try...catch之后的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01TryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            readFile(<span class="string">"d:\\a.tx"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// try 中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常对象</span></span><br><span class="line">            <span class="comment">// 异常处理逻辑</span></span><br><span class="line">            System.out.println(<span class="string">"catch --&gt; 传递的文件后缀不是.txt"</span>);</span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// 文件的后缀名不对</span></span><br><span class="line">            System.out.println(e.toString()); <span class="comment">// java.io.IOException: 文件的后缀名不对</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 同上</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">/*java.io.IOException: 文件的后缀名不对</span></span><br><span class="line"><span class="comment">	at cn.perdant.day15.demo01.Demo01TryCatch.readFile(Demo01TryCatch.java:39)</span></span><br><span class="line"><span class="comment">	at cn.perdant.day15.demo01.Demo01TryCatch.main(Demo01TryCatch.java:25)*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>); <span class="comment">// 后续代码 无论是否发生异常都不影响这句话的执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径没有问题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.11.12</p>
<p><strong>上面的代码用到了Throwable类中定义的3个 异常处理的方法：</strong></p>
<p><code>String getMessage()</code> 返回 throwable 的简短信息</p>
<p><code>String toString()</code> 返回 throwable 的详细信息</p>
<p><code>void printStackTrace()</code> JVM打印异常对象，默认此方法，打印的异常信息是最全面的</p>
<p><strong>finally代码块</strong></p>
<p>对于<code>try</code> 块里面的代码，发生异常后 ，后面的代码是执行不到的。我们可以把这些代码放到<code>finally</code>当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* finally代码块</span></span><br><span class="line"><span class="comment">*   格式：</span></span><br><span class="line"><span class="comment">*   try &#123;</span></span><br><span class="line"><span class="comment">*       可能产生异常的代码</span></span><br><span class="line"><span class="comment">*   &#125;catch(定义一个异常的变量，用来接收try中抛出的异常对象)&#123;</span></span><br><span class="line"><span class="comment">*       异常的处理逻辑，产生异常对象之后，怎么处理异常对象</span></span><br><span class="line"><span class="comment">*       一般在工作中，会把异常的信息记录到一个日志中</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*   ...</span></span><br><span class="line"><span class="comment">*   catch(异常类名 变量名)&#123;</span></span><br><span class="line"><span class="comment">*       catch可以有多个</span></span><br><span class="line"><span class="comment">*   &#125;finally&#123;</span></span><br><span class="line"><span class="comment">*       无论是否出现异常，都会执行。</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. finally不能单独使用，必须和try一起使用</span></span><br><span class="line"><span class="comment">*       2. finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Finally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//可能会产生异常的代码</span></span><br><span class="line">            readFile(<span class="string">"c:\\a.tx"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//异常的处理逻辑</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否出现异常，都会执行</span></span><br><span class="line">            System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径没有问题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>各人见解：</strong> 之前说过，<code>try..catch</code>的一个好处在于，无论是否发生异常，都不影响后面代码的执行，那么写不写<code>finally</code>的区别在哪呢？？我自己试了一下后，才理解了这一节一开始的那一句话：</p>
<blockquote>
<p>对于<code>try</code> 块里面的代码，发生异常后 ，后面的代码是执行不到的。我们可以把这些代码放到<code>finally</code>当中。</p>
</blockquote>
<p>先看一个例题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = demo();</span><br><span class="line">        System.out.println(e); <span class="comment">// finally trumps return. 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally trumps return."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码运行时，实际执行顺序是在<code>return</code>之前执行了<code>finally</code>中的输出语句。 如果不用<code>finally</code>只是单单写在<code>try...catch</code>后面的语句是不会执行的，因为在try里已经<code>return</code>了，这就是所说的无论如何，<code>finally</code>里的代码一定会执行。 但是，还有两点需要注意，看下面的例子。 第一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = demo();</span><br><span class="line">        System.out.println(e); <span class="comment">// 12 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">12</span>;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果按照前面所说的逻辑，为什么不是输出12 12呢？这里涉及到了JVM的深层原理，我还没学到。。。大体意思就是，<code>return</code>里面的值和变量<code>i</code>里面的值 是分开存的，所以<code>finally</code>里面虽然修改了<code>i</code>，但是<code>return</code>里面的值没有变，所以最后返回的仍是2。 第二点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = demo();</span><br><span class="line">        System.out.println(e); <span class="comment">// finally trumps return. 12</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">12</span>;</span><br><span class="line">            System.out.println(<span class="string">"finally trumps return."</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么<code>finally</code>块中不要有<code>return</code>，如果有的话，程序不论是否发生异常，都会执行<code>finally</code>中的语句，最后必定返回的是<code>finally</code> 中的结果。</p>
<h2 id="异常的注意事项">异常的注意事项</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 多个异常使用捕获又该如何处理呢？</span></span><br><span class="line"><span class="comment">        * 1. 多个异常分别处理。</span></span><br><span class="line"><span class="comment">        * 2. 多个异常一次捕获，多次处理。</span></span><br><span class="line"><span class="comment">        * 3. 多个异常一次捕获一次处理*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 多个异常分别处理</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(arr[3]); // ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line"><span class="comment">//        &#125;catch (ArrayIndexOutOfBoundsException e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            List&lt;Integer&gt; list = List.of(1, 2, 3);</span></span><br><span class="line"><span class="comment">//            System.out.println(list.get(3)); // IndexOutOfBoundsException: Index 3 out-of-bounds for length 3</span></span><br><span class="line"><span class="comment">//        &#125; catch (IndexOutOfBoundsException e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 多个异常，一次捕获，多次处理</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">//            System.out.println(arr[3]); // ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line"><span class="comment">//            List&lt;Integer&gt; list = List.of(1, 2, 3);</span></span><br><span class="line"><span class="comment">//            System.out.println(list.get(3)); // IndexOutOfBoundsException: Index 3 out-of-bounds for length 3</span></span><br><span class="line"><span class="comment">//        &#125;catch (ArrayIndexOutOfBoundsException e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IndexOutOfBoundsException e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 一个try 多个catch 注意事项：</span></span><br><span class="line"><span class="comment">        *   catch里面定义的一场变量，如果有子父类关系，那么子类的异常变量，必须写在上边，否则就会报错</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">            System.out.println(arr[3]);</span></span><br><span class="line"><span class="comment">            List&lt;Integer&gt; list = List.of(1, 2, 3);</span></span><br><span class="line"><span class="comment">            System.out.println(list.get(3));</span></span><br><span class="line"><span class="comment">        &#125;catch (IndexOutOfBoundsException e) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(e);</span></span><br><span class="line"><span class="comment">        &#125; catch (ArrayIndexOutOfBoundsException e) &#123; // 报错， ArrayIndexOutOfBoundsException 是 IndexOutOfBoundsException 的子类，必须写在上边</span></span><br><span class="line"><span class="comment">            System.out.println(e);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 多个异常，一次捕获一次处理</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">//            System.out.println(arr[3]);</span></span><br><span class="line"><span class="comment">//            List&lt;Integer&gt; list = List.of(1, 2, 3);</span></span><br><span class="line"><span class="comment">//            System.out.println(list.get(3));</span></span><br><span class="line"><span class="comment">//        &#125;catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行期异常被抛出可以不处理，即不捕获也不声明抛出。</span></span><br><span class="line">        <span class="comment">// 默认给虚拟机处理，终止程序，什么时候不抛出运行期异常了，再来执行程序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]); <span class="comment">// ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果finally有return语句，永远返回finally中的结果，避免该情况！（finally中是一定会执行的代码）</li>
<li>如果父类抛出多个异常，子类重写父类方法时，抛出和父类相同的异常或者是抛出父类抛出的异常的子类或者不抛出异常。</li>
<li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出，简而言之：<strong>父类异常是什么样，子类异常就是什么样</strong></li>
<li>在<code>try...catch</code>后可以追加<code>finally</code>代码块，其中的代码一定会被执行，通常用于资源回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException,ClassCastException</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException,ClassCastException</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抛出和父类相同的异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException,ClassCastException</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类异常的子类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不抛出异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"编译期异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常">自定义异常</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自定义异常类：</span></span><br><span class="line"><span class="comment">*   java提供的异常类，不够我们使用，需要自己定义一些异常类</span></span><br><span class="line"><span class="comment">* 格式：</span></span><br><span class="line"><span class="comment">*   public class XXXException extends Exception | RuntimeException&#123;</span></span><br><span class="line"><span class="comment">*       添加一个空参数的构造方法</span></span><br><span class="line"><span class="comment">*       添加一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* 注意：</span></span><br><span class="line"><span class="comment">*   1. 自定义异常类命名一般都是以Exception结尾，说明该类是一个异常类</span></span><br><span class="line"><span class="comment">*   2. 自定义异常类，必须的继承Exception或者RuntimeException</span></span><br><span class="line"><span class="comment">*           继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try...catch</span></span><br><span class="line"><span class="comment">*           继承RuntimeException：那么自定义的异常类就是一个运行期异常，可以不处理，交给虚拟机处理（中断处理）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个空参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一个带异常信息的构造方法 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部回调用父类带异常信息的构造方法，让父类来处理这个异常信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程">多线程</h1>
<h2 id="并发与并行">并发与并行</h2>
<p>并发：指两个或多个事件在同一个时间段内发生 并行：指两个或多个事件在同一时刻发生（同时发生） <img src="\image\37.1_并发与并行.bmp" /></p>
<h2 id="线程和进程">线程和进程</h2>
<ul>
<li><strong>进程：</strong>是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li>
<li><strong>线程：</strong> 是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</li>
</ul>
<p>进程： <img src="\image\37.2_进程概念.bmp" /></p>
<p>线程： <img src="\image\37.2_线程概念.bmp" /></p>
<p><strong>线程的调度</strong> 分时调度：轮流使用cpu 抢占式调度：谁的优先级高，谁来抢占cpu （java使用的此种调度）</p>
<p><strong>各人思考：</strong> 一个程序有多个进程，一个进程有多个线程， 线程和cpu是什么关系？网上找了些资料，先说结论：<strong>多线程和cpu有几个核没关系</strong>，单核也可以开多线程，cpu在多个线程间来回切换，多核开多线程的优势在于速度更快罢了。</p>
<p>下面放上我在网上找的摘录： &gt;1. CPU和线程的关系 &gt;（1）第一阶段，单CPU时代，单CPU在同一时间点，只能执行单一线程。比如，的某一刻00:00:00 这一秒，只计算1＋1=2（假设cpu每秒计算一次） &gt;（2）第二阶段，单CPU多任务阶段，计算机在同一时间点，并行执行多个线程。但这并非真正意义上的同时执行，而是多个任务共享一个CPU，操作系统协调CPU在某个时间点，执行某个线程，因为CPU在线程之间切换比较快，给人的感觉，就好像多个任务在同时运行。比如，电脑开了两个程序qq和qq音乐，假设这两个程序都只有一个线程。人能够感觉到CPU切换的频率是一秒一次，假设当前cpu计算速度是1秒1次，那么我们就能明显感到卡顿，当聊天，点击发送按钮时候，qq音乐就会停止运行。当前cpu计算速度是1秒100次，也就是它能在一秒之内在这两个进程见切换100次，那么我们就感不到卡顿，觉得QQ和QQ音乐是同时在运行。 &gt;（3）第三阶段，多CPU多任务阶段，真正实现的，在同一时间点运行多个线程。具体到哪个线程在哪个CPU执行，这就跟操作系统和CPU本身的设计有关了。 &gt;1. 举例说明 &gt;（1）假设一种极端情况，一台单核计算机，只运行2个程序A和B。 &gt;假设A和B的优先级相同，A有3个线程，B有1个线程，那么CPU分配给A和B的执行时间应该是3:1。 &gt;（2）假设同一种情况发生在一台多核计算机，核1处理A和B各一个线程，核2处理A剩下的线程。 &gt;（3）刚才说的是线程只消耗CPU，在实际应用中这种情况是不存在的，程序总会跟资源打交道，比如读个文件，查询数据库，访问网络，这个时候多线程才能体现出优势。在一个进程中，让A先用一下CPU去查询数据库，在A查询数据库的时候CPU空闲，B就用一CPU去读文件，让C去访问网络。相对于查询数据库，读取文件这些操作来说，CPU的计算时间几乎可以忽略不计。所以，多线程，实际上是计算机多种资源的并行运用，跟CPU有几个核心没什么关系。</p>
<h2 id="主线程">主线程：</h2>
<p><img src="\image\37.3_主线程.bmp" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 主线程：执行主（main）方法的线程</span></span><br><span class="line"><span class="comment">* 单线程程序：java程序中只有一个线程</span></span><br><span class="line"><span class="comment">* 程序从main方法开始，从上到下依次执行</span></span><br><span class="line"><span class="comment">* JVM执行main方法，main方法会进入到栈内存</span></span><br><span class="line"><span class="comment">* JVM会找操作系统开辟一条main方法通向cpu的执行路径</span></span><br><span class="line"><span class="comment">* cpu就可以通过这个路径来执行main方法</span></span><br><span class="line"><span class="comment">* 而这个路径有一个名字，叫main（主）线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01MainThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"伍陆柒"</span>);</span><br><span class="line">        p1.run();</span><br><span class="line">        System.out.println(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// Exception in thread "main" java.lang.ArithmeticException: / by zero</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"梅十三"</span>);</span><br><span class="line">        p2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方式一创建线程类">方式一：创建线程类</h2>
<p>Java使用<code>java.lang.Thread</code> 类代表线程，所有的线程对象都必须是<code>Thread</code>类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流（即一段顺序执行的代码）。Java使用线程执行体来代表这段程序流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建多线程程序的第一种方式：创建Thread类的子类</span></span><br><span class="line"><span class="comment">* java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类</span></span><br><span class="line"><span class="comment">* 实现步骤：</span></span><br><span class="line"><span class="comment">*   1. 创建一个Thread类的子类</span></span><br><span class="line"><span class="comment">*   2. 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程要做什么？）</span></span><br><span class="line"><span class="comment">*   3. 创建Thread类的子类对象</span></span><br><span class="line"><span class="comment">*   4. 调用Thread类中的方法start方法，开启新的线程，执行run方法。</span></span><br><span class="line"><span class="comment">*       此时就有两个线程，main线程和创建的新线程，两个并发运行</span></span><br><span class="line"><span class="comment">*       多次启动一个线程是非法的，当线程已经结束执行后，不能再重新启动。</span></span><br><span class="line"><span class="comment">*       java属于抢占式调度，哪个线程优先级高，哪个线程优先执行，优先级相等时，随机选择一个执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 4.调用start方法</span></span><br><span class="line">        mt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2.重写run 设置线程任务</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run:"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多线程原理：</strong> <img src="\image\37.3_多线程随机性打印结果.bmp" /></p>
<p><strong>多线程内存图解：</strong> <img src="\image\37.3_多线程内存图解.bmp" /></p>
<p>上述记录于2019.11.13</p>
<h2 id="thread类">Thread类</h2>
<p><strong>常用方法</strong></p>
<p><code>currentThread()</code> <code>getName()</code> <code>setName()</code> <code>sleep()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取线程的名称</span></span><br><span class="line"><span class="comment"> *   1. 使用Thread类中的方法getName()</span></span><br><span class="line"><span class="comment"> *   2. 可以先获取到当前正在执行的线程currentThread，再使用线程中的方法getName()获取线程的名称</span></span><br><span class="line"><span class="comment"> * 设置线程的名称</span></span><br><span class="line"><span class="comment"> *   1. 使用Thread类中的方法setName(名字)</span></span><br><span class="line"><span class="comment"> *   2. 创建一个带参数的构造方法，参数传递线程的名称；调用父类的带参构造方法，把线程名称传递给父类，让父类（Thread）给子线程起一个名字。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写run 设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*            String name = getName();</span></span><br><span class="line"><span class="comment">            System.out.println(name);*/</span></span><br><span class="line"><span class="comment">/*            Thread t = Thread.currentThread();</span></span><br><span class="line"><span class="comment">//            System.out.println(t);  // Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">            String name = t.getName();</span></span><br><span class="line"><span class="comment">            System.out.println(name);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">// 链式编程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 线程的名称：</span></span><br><span class="line"><span class="comment">*   主线程：main</span></span><br><span class="line"><span class="comment">*   新线程：Thread-0，Thread-1，Thread-2 ...*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//        mt.start(); // Thread-0</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().start(); <span class="comment">// Thread-1</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().start(); <span class="comment">// Thread-2</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">// main</span></span><br><span class="line">        mt.setName(<span class="string">"伍陆柒"</span>);</span><br><span class="line">        mt.start(); <span class="comment">// 伍陆柒</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"梅十三"</span>).start(); <span class="comment">//梅十三</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* public static void sleep(long millis): 使当前正在执行的线程以指定的毫秒数暂时停止执行</span></span><br><span class="line"><span class="comment">* 毫秒数结束之后，线程继续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Sleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span> ; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用Thread类的sleep方法，让程序睡眠1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方式二实现runnable接口">方式二：实现Runnable接口</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建多线程程序的第二种方式：实现Runnable接口</span></span><br><span class="line"><span class="comment">* 实现步骤：</span></span><br><span class="line"><span class="comment">*   1. 创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="comment">*   2. 在实现类中重写Runnable接口的run方法，设置线程任务</span></span><br><span class="line"><span class="comment">*   3. 创建一个Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">*   4. 创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">*   5. 调用Thread类中的start方法，开启新的线程执行run方法</span></span><br><span class="line"><span class="comment">* 好处：</span></span><br><span class="line"><span class="comment">* 	1. 避免了单继承的局限性</span></span><br><span class="line"><span class="comment">* 		一个类只能继承一个类，类继承了Thread类就不能继承其他的类了</span></span><br><span class="line"><span class="comment">* 		实现了Runnable接口，还可以继承其他的类，实现其他的接口</span></span><br><span class="line"><span class="comment">* 	2. 增强了程序的扩展性，降低了程序的耦合性（解耦）</span></span><br><span class="line"><span class="comment">* 		实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）</span></span><br><span class="line"><span class="comment">* 		实现类中，重写了run方法，用来设置线程任务</span></span><br><span class="line"><span class="comment">* 		创建Thread类对象，调用start方法，用来开启新线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建一个Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">// 4. 创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        <span class="comment">// 5. 调用Thread类中的start方法，开启新的线程执行run方法</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 在实现类中重写Runnable接口的run方法，设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后多线程，尽量使用实现Runnable接口的方式</p>
<h2 id="匿名内部类方式实现线程创建">匿名内部类方式实现线程创建</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo03;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匿名内部类作用：简化代码</span></span><br><span class="line"><span class="comment">*   把子类继承父类，重写父类的方法，创建子类对象合一步完成</span></span><br><span class="line"><span class="comment">*   把实现类实现接口，重写接口中的方法，创建实现类对象合一步完成</span></span><br><span class="line"><span class="comment">* 匿名内部类最终产物：子类/实现类对象，而这个类没有名字</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 格式：</span></span><br><span class="line"><span class="comment">*   new 父类/接口()&#123;</span></span><br><span class="line"><span class="comment">*       重写父类/接口中的方法</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 继承Thread类的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现Runnable接口的方式</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更加简化接口的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程安全">线程安全</h1>
<p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<h2 id="线程安全问题概述">线程安全问题概述</h2>
<p><img src="\image\38.1_线程安全问题的概述.bmp" /></p>
<p><strong>线程安全问题示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo04;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模拟卖票案例</span></span><br><span class="line"><span class="comment">* 创建三个线程，同时开启*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*实现卖票案例*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 设置线程任务 买票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环，卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率，让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 票存在，卖票</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在卖第："</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong> <img src="\image\38.1_运行结果.png" /></p>
<p><strong>线程安全问题产生原理分析：</strong> <img src="\image\38.1_线程安全问题产生的原理.bmp" /></p>
<p>为了解决解决线程安全问题采用<strong>线程同步技术</strong></p>
<p><strong>同步技术的原理：</strong> <img src="\image\38.2_同步的原理.bmp" /> 这张图要结合下面的几种技术的代码例子来理解</p>
<h2 id="技术一同步代码块">技术一：同步代码块</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决线程安全问题的一种方案：使用同步代码块</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">    synchronized(锁对象)&#123;</span></span><br><span class="line"><span class="comment">        可能会出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">    1. 通过代码块种的锁对象，可以使用任意的对象</span></span><br><span class="line"><span class="comment">    2. 但是必须保证多个线程使用的锁对象是同一个</span></span><br><span class="line"><span class="comment">    3. 锁对象作用：</span></span><br><span class="line"><span class="comment">        把同步代码块锁住，只让一个线程在同步代码块种执行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 设置线程任务 买票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环，卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 提高安全问题出现的概率，让程序睡眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 票存在，卖票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"正在卖第："</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模拟卖票案例</span></span><br><span class="line"><span class="comment">* 创建三个线程，同时开启*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="技术二同步方法">38.3 技术二：同步方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment">解决线程安全问题的一种方案：使用同步方法</span></span><br><span class="line"><span class="comment">使用步骤：</span></span><br><span class="line"><span class="comment">    1. 把访问了共享数据的代码抽取出来，放到一个方法中</span></span><br><span class="line"><span class="comment">    2. 在方法上添加synchronized修饰符</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符 synchronized 返回值类型 方法名(参数列表)&#123;</span></span><br><span class="line"><span class="comment">    访问了共享数据的代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程任务 买票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环，卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用同步方法</span></span><br><span class="line">            payTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个同步方法</span></span><br><span class="line"><span class="comment">    同步方法的原理本质和同步代码块一样</span></span><br><span class="line"><span class="comment">    同步方法也会把方法内部的代码锁住只让一个线程执行</span></span><br><span class="line"><span class="comment">    同步方法的锁对象就是this 也就是这里定义的类 RunnableImpl new的实例对象！</span></span><br><span class="line"><span class="comment">    相比同步代码块，同步方法不需要在RunnableImpl类中单独new一个锁对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 提高安全问题出现的概率，让程序睡眠</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 票存在，卖票</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第："</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态同步方法：</strong> 静态同步方法的锁对象不是this，因为this是创建对象之后产生的，静态方法优先于对象 静态方法的锁对象是本类的class属性 --&gt; class文件对象（反射，后面会讲）</p>
<h2 id="技术三lock锁技术">技术三：Lock锁技术</h2>
<p>JDK1.5后的新接口<code>java.util.concurrent.locks</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决线程安全问题的一种方案：使用Lock锁</span></span><br><span class="line"><span class="comment">    比synchronized更加先进好用</span></span><br><span class="line"><span class="comment">    两个方法lock() unlock()</span></span><br><span class="line"><span class="comment">    实现类ReentrantLock</span></span><br><span class="line"><span class="comment">使用步骤：</span></span><br><span class="line"><span class="comment">    1. 在成员位置创建一个ReentrantLock对象</span></span><br><span class="line"><span class="comment">    2. 可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line"><span class="comment">    3. 可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1. 在成员位置创建一个ReentrantLock对象</span></span><br><span class="line">    Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 设置线程任务 买票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环，卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率，让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">// 票存在，卖票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"正在卖第："</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line">                    l.unlock(); <span class="comment">// 无论程序是否异常，都会把锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程状态">线程状态</h1>
<p><img src="\image\39_线程的状态图.bmp" /></p>
<p><strong>计时等待（Timed Waiting）</strong> <img src="\image\39_计时等待.png" /></p>
<p><strong>锁阻塞（Blocked）</strong> <img src="\image\39_锁阻塞.png" /></p>
<p><strong>无限等待（Waiting）</strong> <img src="\image\39_无限等待.png" /></p>
<h2 id="等待唤醒机制">等待唤醒机制</h2>
<p><img src="\image\39.1_等待唤醒案例分析.bmp" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo08;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   等待唤醒案例：线程之间的通信</span></span><br><span class="line"><span class="comment">        创建一个顾客线程（消费者）：告知老板要的包子的种类和数量，调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）</span></span><br><span class="line"><span class="comment">        创建一个老板线程（生产者）：花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子</span></span><br><span class="line"><span class="comment">   注意：</span></span><br><span class="line"><span class="comment">        顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行</span></span><br><span class="line"><span class="comment">        同步使用的锁对象必须保证唯一</span></span><br><span class="line"><span class="comment">        只有锁对象才能调用wait和notify方法</span></span><br><span class="line"><span class="comment">        这两个方法都来自Object类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建锁对象</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建顾客线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123; <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"告知老板包子的种类和数量"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）</span></span><br><span class="line">                            obj.wait();  <span class="comment">// 这里只能try...catch不能throws 因为其父类Thread没有throws！</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">"包子好了 开吃！"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"================="</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建老板线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 5秒钟做包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"老板做好包子，告知顾客"</span>);</span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码示例就是先熟悉一下锁对象调用的两个方法：<code>wait</code> 和 <code>notify</code> 记住！这俩是锁对象调用的！ 线程类调用的是<code>start</code> <code>sleep</code> <code>currentThread</code></p>
<p><strong>各人见解：</strong> <code>wait</code>和 <code>notify</code> 进入的这种无线等待模式的好处是什么呢？ 之前卖票的例子里我们可以看到，虽然加入了同步技术解决了线程安全问题，但是，线程的运行顺序是没有规则的，谁抢到cpu谁就运行，但是如果我规定，奇数票必须第一个线程买，偶数票第二个线程卖呢？如果使用<code>wait</code>和<code>notify</code> 就可以让线程一在票数为奇数的时候<code>notify</code> 不是奇数的时候 <code>wait</code> 线程二同理。这样就可以让线程有一个规则顺序执行。（你们可以自己试一下卖票这个题,我自己写了一个，参见<strong>39.3 练习</strong>）</p>
<p>这也就是下面要讲的：线程间的通信。</p>
<h2 id="线程间通信">线程间通信</h2>
<p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 例如前面的包子案例，顾客线程吃包子，老板线程做包子</p>
<p><strong>为什么要处理线程间通信：</strong> 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong> 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<p><strong>代码案例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo09;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   资源类：包子类</span></span><br><span class="line"><span class="comment">   设置包子的属性</span></span><br><span class="line"><span class="comment">        皮</span></span><br><span class="line"><span class="comment">        陷</span></span><br><span class="line"><span class="comment">        包子的状态：有 true 没有 false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 皮</span></span><br><span class="line">    String pi;</span><br><span class="line">    <span class="comment">// 陷</span></span><br><span class="line">    String xian;</span><br><span class="line">    <span class="comment">// 包子的状态：有 true 没有 false</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo09;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者 包子铺 类： 是一个线程类</span></span><br><span class="line"><span class="comment">    run：</span></span><br><span class="line"><span class="comment">    有包子 wait</span></span><br><span class="line"><span class="comment">    没有包子 生产包子 改变包子状态 唤醒吃货线程</span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">        包子铺线程和吃货线程是通信（互斥）关系</span></span><br><span class="line"><span class="comment">        必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line"><span class="comment">        锁对象必须保证唯一，可以使用包子对象作为锁对象</span></span><br><span class="line"><span class="comment">        包子铺类和吃货类需要把包子对象作为参数传递进来</span></span><br><span class="line"><span class="comment">           1. 需要在成员位置创建一个包子变量</span></span><br><span class="line"><span class="comment">           2. 使用带参数的构造方法，为这个包子变量赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 需要在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用带参数的构造方法，为这个包子变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 一直生产包子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bz.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 被唤醒之后执行 包子铺生产包子</span></span><br><span class="line">                <span class="comment">// 增加趣味性，交替生产两种包子</span></span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 生产薄皮包子</span></span><br><span class="line">                    bz.pi = <span class="string">"薄皮"</span>;</span><br><span class="line">                    bz.xian = <span class="string">"三鲜馅"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bz.pi = <span class="string">"冰皮"</span>;</span><br><span class="line">                    bz.xian = <span class="string">"牛肉大葱馅"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">"包子铺正在生产："</span> + bz.pi + bz.xian + <span class="string">"包子"</span>);</span><br><span class="line">                <span class="comment">// 生产包子需要3秒钟</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产好后 修改包子的状态</span></span><br><span class="line">                bz.flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒吃货线程</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">"包子铺已经生产好了:"</span> + bz.pi + bz.xian + <span class="string">"包子,吃货可以开始吃了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo09;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    类似包子铺类，定义一个吃货类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 需要在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用带参数的构造方法，为这个包子变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置线程任务 吃包子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span> (bz.flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 被唤醒之后 执行的代码</span></span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃："</span>+ bz.pi + bz.xian + <span class="string">"包子"</span>);</span><br><span class="line">                <span class="comment">// 吃完修改包子状态</span></span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 唤醒包子铺线程</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">"吃货已经把"</span>+ bz.pi + bz.xian + <span class="string">"包子吃完了，包子铺开始生产"</span>);</span><br><span class="line">                System.out.println(<span class="string">"============================================================="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 包子对象</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line">        <span class="comment">// 包子铺线程</span></span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(bz).start();</span><br><span class="line">        <span class="comment">// 吃货线程</span></span><br><span class="line">        <span class="keyword">new</span> ChiHuo(bz).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 票</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//售票窗口1： 只卖偶数票</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ticket ticket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellTicket1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellTicket1</span><span class="params">(Ticket ticket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ticket = ticket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket.flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ticket.tickets%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; ticket.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ticket.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ticket.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"窗口1正在卖第："</span> + ticket.tickets + <span class="string">"张票"</span>);</span><br><span class="line">                        ticket.tickets--;</span><br><span class="line">                        ticket.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"窗口1票卖完了"</span>);</span><br><span class="line">                        ticket.flag = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 售票窗口2:只卖奇数票</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Ticket ticket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellTicket2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellTicket2</span><span class="params">(Ticket ticket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ticket = ticket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket.flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ticket.tickets % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; ticket.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ticket.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ticket.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"窗口2正在卖第："</span> + ticket.tickets + <span class="string">"张票"</span>);</span><br><span class="line">                        ticket.tickets--;</span><br><span class="line">                        ticket.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"窗口2票卖完了"</span>);</span><br><span class="line">                        ticket.flag = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序卖票</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket tc = <span class="keyword">new</span> Ticket();</span><br><span class="line">        SellTicket1 s1 = <span class="keyword">new</span> SellTicket1(tc);</span><br><span class="line">        SellTicket2 s2 = <span class="keyword">new</span> SellTicket2(tc);</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(s1);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s2);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于1029.11.14</p>
<h1 id="线程池">线程池</h1>
<h2 id="线程池思想概述">线程池思想概述</h2>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。</p>
<h2 id="线程池概念">线程池概念</h2>
<p><strong>线程池：</strong>其实就是一个容纳多个线程的容器（还记得前面学的容器吗？ <code>Collection</code> <code>Map</code> ），其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p>
<p><strong>线程池的工作原理：</strong> <img src="image\40.2_线程池原理.bmp" /></p>
<p><strong>合理利用线程池能够带来三个好处：</strong> 1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<h2 id="线程池的使用">线程池的使用</h2>
<p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用<code>Executors</code>工程类来创建线程池对象。</p>
<p><strong>Executors类中有个创建线程池的方法如下：</strong> - <code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢？ 方法如下： - <code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行 - <code>void shutdown()</code> 关闭/销毁线程池的方法 &gt; Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
<p><strong>使用线程池中线程对象的步骤：</strong> 1. 创建线程池对象。 2. 创建Runnable接口子类对象。(task) 3. 提交Runnable接口子类对象。(take task) 4. 关闭线程池(一般不做)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建线程池对象</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 3. 提交Runnable接口子类对象</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-2创建了一个新的线程执行</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-1创建了一个新的线程执行</span></span><br><span class="line">        <span class="comment">// 线程池会一直开启，使用完了线程，会自动把线程归还给线程池，线程池可以继续使用</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-1创建了一个新的线程执行</span></span><br><span class="line">    <span class="comment">// 4. 关闭线程池(一般不做)。</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="comment">// es.submit(new RunnableImpl()); // 抛出异常，线程池没有了，不能获取线程了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 创建Runnable接口子类对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"创建了一个新的线程执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程池底层原理：</strong> <img src="image\40.3_线程池底层原理.png" /></p>
<h1 id="lambda-表达式">Lambda 表达式</h1>
<h2 id="函数式编程思想概述">函数式编程思想概述</h2>
<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p><strong>面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情</strong> <strong>函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</strong></p>
<h2 id="传统写法">传统写法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用实现Runnable接口的方式实现多线程程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">// 创建Thread类对象，构造方法中传递Runnable接口的实现类</span></span><br><span class="line">        Thread t= <span class="keyword">new</span> Thread(run);</span><br><span class="line">        <span class="comment">// 调用start方法开启新线程，执行run方法</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化代码，使用匿名内部类实现多线程程序</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"新线程创建了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续简化上面的代码</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"新线程创建了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo11;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建Runnable接口的实现类，重写run方法，设置线程任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"新线程创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于<code>Runnable</code>的匿名内部类用法（详情见 37.7）可以分析出几点内容：</strong></p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="编程思想转换">编程思想转换</h2>
<p><strong>做什么，而不是怎么做</strong></p>
<p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="lamda写法">Lamda写法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day15.demo11;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lambda省去面向对象的条条框框，格式由**3个部分**组成：</span></span><br><span class="line"><span class="comment">一些参数</span></span><br><span class="line"><span class="comment">一个箭头</span></span><br><span class="line"><span class="comment">一段代码</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span></span><br><span class="line"><span class="comment">格式说明：</span></span><br><span class="line"><span class="comment">小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</span></span><br><span class="line"><span class="comment">`-&gt;`是新引入的语法格式，代表指向动作。</span></span><br><span class="line"><span class="comment">大括号内的语法与传统方法体要求基本一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Lamda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类的方式，实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"新线程创建了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lamda表达式，实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"新线程创建了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        invokeCalc(<span class="number">10</span>, <span class="number">20</span>, <span class="keyword">new</span> Calculator() &#123; <span class="comment">// 匿名内部类，实现Calculator接口</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lamda表达式</span></span><br><span class="line">        invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;&#123; <span class="comment">// 接口名，方法名 都省略了！ 比匿名内部类还简洁。</span></span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = c.calc(a,b);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda省略格式">Lambda省略格式</h2>
<p><strong>可推导即可省略：</strong></p>
<p>可推导可省略类似之前讲到的泛型，泛型在赋值号右边new出来的泛型可以不用写，因为赋值号左边写了，可以推导出右边的泛型。 Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);  <span class="comment">// 参数类型，return 大括号和分号全都省略了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lambda标准格式的省略规则：</strong></p>
<ol type="1">
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。必须一起省略！</li>
</ol>
<h2 id="lambda的使用前提">Lambda的使用前提</h2>
<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。</p>
<p><strong>但是使用时有几个问题需要特别注意：</strong> 1. 使用Lambda<strong>必须具有接口</strong>，且要求<strong>接口中有且仅有一个抽象方法</strong>。 无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 2. 使用Lambda必须具有<strong>上下文推断</strong> 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例 &gt; 备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
<p>上述记录于2019.11.15</p>
<h1 id="file类">File类</h1>
<h2 id="概述">概述</h2>
<p><code>java.io.File</code> 类：<code>Java</code>把电脑中的文件和文件夹（目录）封装为一个<code>File</code>类，与操作系统无关，我们可以使用<code>File</code>类对文件和文件夹进行操作：</p>
<ul>
<li>创建一个文件/文件夹</li>
<li>删除一个文件/文件夹</li>
<li>获取一个文件/文件夹</li>
<li>判断文件/文件夹是否存在</li>
<li>对文件夹进行遍历</li>
<li>获取文件的大小</li>
</ul>
<p>上述记录于2019.11.19</p>
<h2 id="静态成员变量">静态成员变量</h2>
<p><code>File.pathSeparator</code> : 路径分隔符 在<strong>配置环境变量</strong>里提到过<code>path</code>里面就用到了这种分隔符 <code>File.separator</code>：名称分隔符</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pathSeparator = File.pathSeparator; <span class="comment">// 与系统有关的路径分隔符</span></span><br><span class="line">        System.out.println(pathSeparator);  <span class="comment">// ； 路径分隔符 Windows：分号，Linux：冒号</span></span><br><span class="line">        String separator = File.separator;  <span class="comment">// 与系统有关的默认名称分隔符</span></span><br><span class="line">        System.out.println(separator); <span class="comment">// \ 文件名称分隔符 Windows：反斜杠\，Linux：正斜杠/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径">路径</h2>
<p><strong>绝对路径</strong>：是一个完整的路径，以盘符（C:,D:）开始的 <strong>相对路径</strong>：是一个简化的路径，如果文件存储在与当前项目同一个的<strong>根目录</strong>下的话，可以不写根目录之前的路径，只写根目录之后的路径。</p>
<blockquote>
<p>什么是根目录，比如我后面反复用到的路径<code>"D:\\IdeaProjects\\basic-code\\..."</code> 这里我写的所有代码都是<code>basic-code</code>目录下建立的各种<code>module</code>中，所以这里的根目录是<code>basic-code</code>，只要是在<code>basic-code</code>目录下的文件/文件夹，<code>basic-code</code>之前的路径，包括<code>basic-code</code>都可以省略。</p>
</blockquote>
<p><strong>注意：</strong></p>
<ol type="1">
<li>路径不区分大小写</li>
<li>路径中的文件名称分隔符Windows使用反斜杠<code>\\</code>，单个反斜杠是转义字符，所以要用两个反斜杠代表一个普通的反斜杠</li>
</ol>
<h2 id="构造方法-1">构造方法</h2>
<ol type="1">
<li><code>File(String pathname)</code> 参数：字符串的路径名称</li>
</ol>
<ul>
<li>可以以文件结尾，也可以是文件夹结尾</li>
<li>可以是绝对路径，也可以是相对路径</li>
<li>可以是存在的，也可以是不存在</li>
</ul>
<ol start="2" type="1">
<li><p><strong>创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况</strong>说白了，你路径可以随便写，只要符合路径定义的格式就可以了，这里编译器是不会去处理判断你的文件是否存在，你写的路径是否正确等等。因为你还没用这个file类实例做任何操作。</p></li>
<li><p><code>File(String parent, String child)</code> 参数：父路径和子路径 好处：可以单独书写，使用起来非常灵活，父子路径都可以变化</p></li>
<li><p><code>File(File parent, String child)</code> 参数：父路径是File类型，可以使用File类的方法，对路径进行一些操作，再使用路径创建对象</p></li>
</ol>
<h2 id="获取的方法">获取的方法</h2>
<ol type="1">
<li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串</p></li>
<li><p><code>public String getPath()</code>：获取构造方法中传递的路径。 构造方法中用的是绝对路径，就返回绝对路径，用的是相对路径，就返回相对路径。<code>toString</code> 的源码调用的就是 <code>getPath</code>方法</p></li>
<li><p><code>public String getName()</code> ：获取构造方法传递的路径的结尾部分，就是只返回路径的最后一层的文件/文件夹</p></li>
<li><p><code>public long length()</code> ：获取的是构造方法指定的文件的大小，以字节为单位。注意：文件夹是没有大小概念的，不能获取文件夹的大小，方法返回0；如果构造方法中给出的路径不存在，也返回0</p></li>
</ol>
<h2 id="判断的方法">判断的方法</h2>
<ol type="1">
<li><p><code>public boolean exists()</code> ：用于判断构造方法中的路径是否存在</p></li>
<li><p><code>public boolean isDirectory()</code> ：用于判断构造方法中的路径是否以文件夹结尾</p></li>
<li><p><code>public boolean isFile()</code> ：与上一方法相反，用于判断构造方法中的路径是否以文件结尾</p></li>
<li><p>2、3 方法是互斥的，一个返回<code>true</code>另一个就返回<code>false</code>。但是如果使用这两个方法时<code>file</code>构造时传递的<strong>路径</strong>是不存在的，都返回<code>false</code></p></li>
</ol>
<h2 id="创建删除的方法">创建/删除的方法</h2>
<ol type="1">
<li><code>public boolean createNewFile()</code> ：</li>
</ol>
<ul>
<li>当且仅当具有该名称的文件尚不存在时，创建一个新的空文件，返回<code>true</code></li>
<li>如果文件存在或者有同名的文件夹存在，返回<code>false</code></li>
<li>创建文件的路径和名称，在构造方法中给出（构造方法的参数）</li>
<li>如果路径不存在，抛出IOException，因此调用时必须处理异常。<code>try...catch</code> or <code>throws</code></li>
<li><strong>此方法只能创建文件，不能创建文件夹。</strong></li>
</ul>
<ol start="2" type="1">
<li><code>public boolean delete()</code> ：</li>
</ol>
<ul>
<li>删除构造方法路径给出的文件/文件夹</li>
<li>文件/文件夹 删除成功 返回<code>true</code></li>
<li>文件夹中有内容，不会删除，返回<code>false</code></li>
<li>构造方法中的路径不存在，返回<code>false</code></li>
<li>此方法直接在硬盘删除文件/文件夹，不走回收站</li>
</ul>
<ol start="3" type="1">
<li><p><code>public boolean mkdir()</code> ：创建单级空文件夹</p></li>
<li><p><code>public boolean mkdirs()</code> ：既可以创建单级空文件夹，也可以创建多级空文件夹。</p></li>
<li><p>对于3、4两种方法：</p></li>
</ol>
<ul>
<li>如果文件夹不存在，创建并返回<code>true</code></li>
<li>如果文件夹存在，返回<code>false</code>；如果路径不存在，也返回<code>false</code></li>
<li>只能创建文件夹，不能创建文件。就算你路径里写的<code>xxx.txt</code>，创建的照样是一个名字为 <code>xxx.txt</code>的文件夹，这里的<code>.txt</code>并不是文件后缀，只是当作文件夹名字来处理了</li>
</ul>
<h3 id="目录的遍历">目录的遍历</h3>
<ol type="1">
<li><p><code>public String[] list()</code> ：遍历构造方法中给出的目录，会获取目录下所有文件/文件夹的名称，把获取到的文件/文件夹的名称存储到一个 <code>String[]</code> 数组里。</p></li>
<li><p><code>public File[] listFiles()</code> ：遍历构造方法中给出的目录，会获取目录下所有文件/文件夹的名称，把获取到的文件/文件夹封装为<code>File</code>对象，存储到一个 <code>File[]</code> 数组里。</p></li>
<li><p>对于1、2两种方法：</p></li>
</ol>
<ul>
<li>如果路径不存在或者不是一个合法路径，抛出空指针异常<code>NullPointerException</code></li>
<li>可以遍历到<strong>隐藏</strong>的文件/文件夹</li>
</ul>
<h1 id="递归">递归</h1>
<h2 id="概述-1">概述</h2>
<p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
<h2 id="递归的分类">递归的分类</h2>
<p>递归分为两种：</p>
<p><strong>直接递归</strong>：方法自身调用自己。 <strong>间接递归</strong>：A方法调用B方法，B方法调用C方法，C方法调用A方法。</p>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出<code>StackOverflowError</code>（方法进栈，然后再次调用方法自身，只有进栈，没有出栈。就会导致栈内存中有无数个方法。从而超出栈内存的大小。）</p></li>
<li><p>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</p></li>
<li><p>构造方法，禁止递归，否则编译报错。（构造方法是创建对象使用的，递归会导致内存中有无数多个对象！）</p></li>
</ul>
<p><strong>递归的使用前提：</strong>当调用方法的时候，方法的主体不变，每次调用方法的参数不同</p>
<p><strong>使用递归必须明确：</strong></p>
<ol type="1">
<li>递归的结束条件</li>
<li>递归的目的</li>
</ol>
<h2 id="练习-1">练习</h2>
<h3 id="计算1-n的和">计算1 ~ n的和</h3>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = sum(<span class="number">3</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123; <span class="comment">// 1. 递归的结束条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + sum(n-<span class="number">1</span>); <span class="comment">// 2. 递归的目的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n的阶乘">n的阶乘</h2>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = jc(<span class="number">5</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123; <span class="comment">// 1. 递归的结束条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n*jc(n-<span class="number">1</span>); <span class="comment">// 2. 递归的目的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归打印多级目录">递归打印多级目录</h2>
<p>如何打印一个目录下的所有文件和文件夹，并且继续打印文件夹里面的文件和文件夹。直到打印到没有文件夹只有文件或空文件夹的底层。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17"</span>); <span class="comment">// 电脑里的任意一个想遍历的目录路径</span></span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(file); <span class="comment">// 先打印当前的目录</span></span><br><span class="line">        File[] files = file.listFiles(); <span class="comment">// 将当前目录下的文件/文件夹存入数组</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123; <span class="comment">// 遍历数组</span></span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                getAllFile(f); <span class="comment">// 如果遍历的是文件夹，迭代</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f); <span class="comment">// 反之，是文件，直接打印</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再进一步思考：如果我并不是想仅仅遍历多级目录，而是想在遍历完这些目录之后，只打印<code>.java</code>结尾的文件呢？其实也简单，去掉打印当前目录的那一步，然后在判断是文件后再加一步检验文件名是否以<code>.java</code>结尾即可。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"day17-code\\src\\cn\\perdant\\day17"</span>); <span class="comment">// 电脑里的任意一个想遍历的目录路径</span></span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.toString().toLowerCase().endsWith(<span class="string">".java"</span>)) &#123; <span class="comment">// 这里多添加一步判断，如果以.java结尾的话(这里加了一步可以忽略大小写)，打印！</span></span><br><span class="line">                    System.out.println(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件过滤器">文件过滤器</h1>
<p>上面这种选择性打印是比较简单的情况，如果遇到复杂的情况呢？如果我们想让这种规则适用于其他的已经写好的遍历文件的代码里呢？这样一次次的修改代码是不是太麻烦了？ 这里，我们引入了一种新的接口：<strong>文件过滤器</strong><code>FileFilter</code>和<code>FilenameFilter</code> 在<code>File</code>类中有两个<code>ListFiles</code>的重载方法，方法的参数传递的就是过滤器</p>
<ol type="1">
<li><code>File[] listFiles(FileFileter filter)</code>
<ul>
<li><code>java.io.FileFilter</code> 接口：用于过滤<code>File</code>对象
<ul>
<li>其中的抽象方法： <code>boolean accept(File pathname)</code> 用来过滤文件的方法</li>
<li>参数：<code>pathname</code> 使用<code>listFiles</code>遍历目录得到的每一个<code>File</code>对象</li>
</ul></li>
</ul></li>
<li><code>File[] listFiles(FilenameFileter filter)</code>
<ul>
<li><code>java.io.FilenameFileter</code> 接口：用于过滤文件名称
<ul>
<li>其中的抽象方法：<code>boolean accept(File dir, String name)</code> 用来过滤文件的方法</li>
<li>参数：
<ul>
<li><code>dir</code>：调用<code>listFiles</code>的<code>File</code>对象（这道题里就是我们一开始给的要遍历的目录封装成的<code>File</code>对象）；</li>
<li><code>name</code>：使用<code>listFiles</code>遍历目录得到的每一个文件/文件夹的名称。</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<p><strong>注意：</strong></p>
<p>两个过滤器接口都没有实现类，需要我们自己写实现类，重写过滤的方法<code>accept</code>，在方法中自己定义过滤的规则。</p>
<p>我们可以把上节的代码使用文件过滤器再一步优化：</p>
<p><strong>代码优化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建过滤器FileFilter的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterImpl</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123; <span class="comment">// 重写accept方法，设置过滤规则</span></span><br><span class="line">        <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 如果是文件夹的话，返回true，可以把该File对象存入数组，方便后面迭代</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果文件名不是以.java结尾，返回false。不允许该File对象存入数组</span></span><br><span class="line">            <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17"</span>); <span class="comment">// 电脑里的任意一个想遍历的目录路径</span></span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        File[] files = file.listFiles(<span class="keyword">new</span> FileFilterImpl()); <span class="comment">// 参数传递过滤器实现类对象 </span></span><br><span class="line">       <span class="comment">// 过滤器实现类accept方法在这里发力了！通过我们重写的规则来决定谁进了File[]数组 谁没进</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123; </span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件过滤器原理">文件过滤器原理</h2>
<p>看不懂代码的话，可以先看看这张原理图，为方便理解，这里的<code>accept</code>规则是<code>return true</code>，就相当于没有过滤，和没加过滤器的效果一样。</p>
<p><img src="\image\java\FileFilter过滤器的原理.bmp" /></p>
<h2 id="终极优化版">终极优化版</h2>
<p>结合之前学到的<strong>匿名内部类</strong>和<strong>Lamda表达式</strong> 我们可以把代码再一次化简，这里我们加上<code>listFiles</code>的另一种重载方法的用法。</p>
<p><strong>代码优化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File( <span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传递FilenameFileter的listFiles方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        File[] files = file.listFiles(</span><br><span class="line">           (dir, name) -&gt; <span class="keyword">new</span> File(dir,name).isDirectory() || name.toLowerCase().endsWith(<span class="string">".java"</span>) <span class="comment">// Lamda表达式省略版写法！注意：这里为了判断是否是文件夹，需要先把dir和name封装成一个File对象，这里用到了前面讲的一种构造方法，父路径File类型的那个。</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 下面迭代操作不变</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 传递FileFileter的listFiles方法</span></span><br><span class="line"><span class="comment">    private static void getAllFile(File file) &#123;</span></span><br><span class="line"><span class="comment">        File[] files = file.listFiles(pathname -&gt; pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java"));</span></span><br><span class="line"><span class="comment">        for (File f : files) &#123;</span></span><br><span class="line"><span class="comment">            if (f.isDirectory()) &#123;</span></span><br><span class="line"><span class="comment">                getAllFile(f);</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(f);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.11.20</p>
<h1 id="io概述">IO概述</h1>
<h2 id="什么是io">什么是IO</h2>
<p>数据的传输，可以看做是一种数据的流动，按照流动的方向，以<strong>内存</strong>为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p>
<p><code>Java</code>中<code>I/O</code>操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p>
<h2 id="io的分类">IO的分类</h2>
<p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<h2 id="顶级父类">顶级父类</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">输入流</th>
<th style="text-align: center;">输出流</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>字节流</strong></td>
<td style="text-align: center;">字节输入流<br /><strong>InputStream</strong></td>
<td style="text-align: center;">字节输出流<br /><strong>OutputStream</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>字符流</strong></td>
<td style="text-align: center;">字符输入流<br /><strong>Reader</strong></td>
<td style="text-align: center;">字符输出流<br /><strong>Writer</strong></td>
</tr>
</tbody>
</table>
<h1 id="字节流">字节流</h1>
<h2 id="一切皆为字节">一切皆为字节</h2>
<p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，8位二进制数就是一个字节，传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h2 id="字节输出流-outputstream">字节输出流 OutputStream</h2>
<p><code>java.io.OutputStream</code> 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的共性方法。</p>
<blockquote>
<p><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。 <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。 <code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。 <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 <code>public abstract void write(int b)</code> ：将指定的字节输出流。</p>
</blockquote>
<h2 id="文件字节输出流-fileoutputstream">文件字节输出流 FileOutputStream</h2>
<p><code>OutputStream</code>有很多子类，下面介绍其最简单的一个子类<code>java.io.FileOutputStream</code>文件输出流，用于将数据写出到文件。</p>
<p><strong>输出数据的原理:</strong></p>
<p>java程序 --&gt; <code>JVM</code>（虚拟机）--&gt; <code>OS</code>（操作系统）--&gt; <code>OS</code>调用写数据的方法，把数据写入到文件中</p>
<p><code>JVM</code>起到一个中介作用，因为不一样的操作系统，文件的某些特殊字符的使用方式是不同的，比如后面要讲的结束符，换行符等等，所以先要将数据交给<code>JVM</code>，<code>JVM</code>将数据处理成<code>OS</code>可以接收的形式，然后<code>OS</code>再与文件做交互，将数据写入文件</p>
<h3 id="构造方法-2">构造方法</h3>
<ul>
<li><p><code>public FileOutputStream(File file)</code></p></li>
<li><p><code>public FileOutputStream(String name)</code></p>
<ul>
<li>参数： 写入数据的目的地
<ul>
<li><code>String name</code> ：目的地是一个文件的路径</li>
<li><code>File file</code>：目的地是一个文件</li>
</ul></li>
</ul></li>
</ul>
<p><strong>构造方法的作用：</strong></p>
<ol type="1">
<li>创建一个<code>FileOutputStream</code>对象</li>
<li>会根据构造方法中传递的文件/文件路径，创建一个空的文件</li>
<li>会把<code>FileOutputStream</code>对象指向创建好的文件</li>
</ol>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会用写入后的文件覆盖原来的文件。</p>
<h3 id="写出字节数据">写出字节数据</h3>
<p><strong>字节输出流的使用步骤：</strong></p>
<ol type="1">
<li>创建一个<code>FileOutputStream</code>对象，构造方法中传入数据的目的地</li>
<li>调用<code>FileOutputStream</code>对象中的方法<code>write</code>，把数据写入到文件中</li>
<li>释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提高程序的效率）</li>
</ol>
<p><strong>写出字节方法：</strong></p>
<ol type="1">
<li><p><code>void write(int b)</code> ，写出一个字节数据</p></li>
<li><p><code>void write(byte[] b)</code>，写出数组中的数据</p></li>
</ol>
<ul>
<li>也可以用 <code>String</code> 类的 <code>getBytes()</code> 方法，将<code>String</code>类型解码成字节，<code>getBytes()</code>默认使用<code>UTF-8</code>的编码表。那我们打开文件想看到我们写的内容，也是必须用<code>UTF-8</code>编码格式打开，不然会乱码。后面<strong>转换流</strong>章节会详细解释</li>
</ul>
<blockquote>
<p>其实打开文件文本编辑器会将字节转换成字符，这步一般的文本编辑器都会自动根据文件内的字节来找到对应的编码表？？</p>
</blockquote>
<ol start="3" type="1">
<li><code>write(byte[] b, int off, int len)</code> , 写出数组中的部分数据
<ul>
<li>参数：
<ul>
<li><code>int off</code> ：数组的开始索引</li>
<li><code>int len</code>：写几个字节</li>
</ul></li>
</ul></li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01OutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个FileOutputStream对象，构造方法中传入数据的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo03\\a.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 调用FileOutputStream对象中的方法write，把数据写入到文件中</span></span><br><span class="line">        <span class="comment">// fos.write(49); // 字节49对应的是字符1</span></span><br><span class="line">        <span class="comment">// fos.write(48); // 0</span></span><br><span class="line">        <span class="comment">// fos.write(48); // 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次写多个字节</span></span><br><span class="line">        <span class="comment">// byte[] bytes = &#123;65, 66, 67, 68, 69&#125;; // ABCDE UTF-8 编码</span></span><br><span class="line">        <span class="comment">// byte[] bytes = &#123;-65, -66, -67, 68, 69&#125;; // 烤紻E 不是乱码。GBK编码 第一个字节是负数，会和第二个字节组成一个中文显示。</span></span><br><span class="line">        <span class="comment">// byte[] bytes = &#123;65, 66, 67, 68, 69&#125;;</span></span><br><span class="line">        <span class="comment">// fos.write(bytes,1,2); // BC 写了数组的一部分 从 索引1 开始 写2个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">"你好"</span>.getBytes(); <span class="comment">// 这里把String变成字节数组</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes)); <span class="comment">// [-28, -67, -96, -27, -91, -67]</span></span><br><span class="line">        fos.write(bytes); <span class="comment">// 你好</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提高程序的效率）</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="追加续写">追加续写</h3>
<p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？<strong>使用两个参数的构造方法</strong></p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code></li>
<li><code>public FileOutputStream(String name, boolean append)</code></li>
</ul>
<p>参数： <code>String name,File file</code>：写入数据的目的地 <code>boolean append</code>：追加写开关</p>
<ul>
<li><code>true</code>：创建对象不会覆盖原文件，继续在文件的末尾追加写数据</li>
<li><code>false</code>：创建一个新文件，覆盖原文件</li>
</ul>
<h3 id="写出换行">写出换行</h3>
<p>使用换行符号：回车符 <code>\r</code> 和换行符号 <code>\n</code> 回车符：回到一行开头（return） 换行符：下一行（newline） 不同操作系统使用的方法不同。 - Windows: <code>\r\n</code> - Linux: <code>/n</code> - Mac: <code>/r</code> 但是从 Mac OS X 后开始与Linux统一</p>
<p>结合续写，代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03OutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo03\\b.txt"</span>,<span class="keyword">true</span>);  <span class="comment">// 把追加写开关打开！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 反复写10次</span></span><br><span class="line">            fos.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line">            fos.write(<span class="string">"\r\n"</span>.getBytes());  <span class="comment">// 每次写完加上换行符号</span></span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字节输入流-inputstream">字节输入流 InputStream</h2>
<p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的共性方法。</p>
<blockquote>
<p><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。 <code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 <code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中</p>
</blockquote>
<h2 id="文件字节输入流-fileinputstream">文件字节输入流 FileInputStream</h2>
<p>仍然是介绍一个子类：<code>java.io.FileInputStream</code>类是文件输入流，用于从文件中读取字节。</p>
<p><strong>输入数据的原理:</strong></p>
<p><code>Java</code>程序 --&gt; <code>JVM</code>（虚拟机）--&gt; <code>OS</code>（操作系统）--&gt; <code>OS</code>调用读数据的方法，把文件的数据读取到内存中</p>
<h3 id="构造方法-3">构造方法</h3>
<ul>
<li><code>FileInputStream(File file)</code></li>
<li><code>FileInputStream(String name)</code></li>
</ul>
<p>参数：读取文件的数据源 <code>String name</code>：文件的路径 <code>File file</code>: 文件</p>
<p>构造方法的作用： 1. 会创建一个<code>FileInputStream</code>对象 2. 会把<code>FileInputStream</code>对象指向构造方法中传入的参数的文件</p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code></p>
<h3 id="读取字节数据">读取字节数据</h3>
<p><strong>字节输入流的使用步骤：</strong></p>
<ol type="1">
<li>创建<code>FileInputStream</code>对象，构造方法中，绑定要读取的数据源</li>
<li>使用<code>FileInputStream</code>对象中的方法<code>read</code>，读取文件</li>
<li>释放资源</li>
</ol>
<p><strong>读取字节方法</strong></p>
<ol type="1">
<li><code>int read()</code>：一次读取一个字节，提升为<code>int</code>型， 读取到文件末尾，返回<code>-1</code>，</li>
<li><code>int read(byte[] b)</code>：一次读取多个字节， 返回读取的有效字节个数</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建FileInputStream对象，构造方法中，绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo03\\a.txt"</span>); <span class="comment">// 这个文件里存的 abc</span></span><br><span class="line">        <span class="comment">// 2. 使用FileInputStream对象中的方法read，读取文件</span></span><br><span class="line"><span class="comment">/*        int len = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(len); // 97 读取到a，转换成int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        len = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(len); // 98 读取到b 同理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        len = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(len); // 99 读取到c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        len = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(len); // -1 读取到结束符，到文件末尾了！*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用循环优化读取多个字节</span></span><br><span class="line"><span class="comment">//        int len = 0; // 记录读取到的字节</span></span><br><span class="line"><span class="comment">//        while ((len = fis.read()) != -1)&#123; // 如果这次读取到的不是结束符</span></span><br><span class="line"><span class="comment">//            System.out.println((char)len); // 打印这次的读取的字节对应的字符</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 一次读取多个字节 效率高</span></span><br><span class="line"><span class="comment">        byte[] bytes = new byte[2];</span></span><br><span class="line"><span class="comment">        int len = fis.read(bytes);</span></span><br><span class="line"><span class="comment">        System.out.println(len); // 2 读取的有效字节个数</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(bytes)); // [97, 98]</span></span><br><span class="line"><span class="comment">        System.out.println(new String(bytes)); // ab</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        len = fis.read(bytes);</span></span><br><span class="line"><span class="comment">        System.out.println(len); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(bytes)); // [99, 98]</span></span><br><span class="line"><span class="comment">        System.out.println(new String(bytes)); // cb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        len = fis.read(bytes);</span></span><br><span class="line"><span class="comment">        System.out.println(len); // -1 读取到的有效字节个数为0，说明读取到文件的结束符了。</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(bytes)); // [99, 98]</span></span><br><span class="line"><span class="comment">        System.out.println(new String(bytes)); // cb</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// while 循环优化</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!= -<span class="number">1</span>)&#123; </span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len)); <span class="comment">// 我只要读取到的有效字节；因为数组剩下位置存的什么并不是这次读取到的字节，所以不用管。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字节流练习图片复制">字节流练习：图片复制</h2>
<p>接下来，来一个结合输入输出流的练习。做一个简单的图片赋值，所有的文件都是字节，图片也不例外，我给大家提供一张我老婆的照片，要求：把我老婆的照片从C盘复制到D盘。</p>
<figure>
<img src="\image\java\我老婆.jpg" alt="" /><figcaption>我老婆</figcaption>
</figure>
<p>新建一个输入流，新建一个输出流。 做一个循环，把每次<code>read</code>的<code>write</code>出去。就ok啦。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 记录一个开始时间</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\我老婆.jpg"</span>); <span class="comment">// 文件输入流 用来读取</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\我老婆.jpg"</span>); <span class="comment">// 文件输出流 用来写出</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*        while((len = fis.read())!= -1) &#123;</span></span><br><span class="line"><span class="comment">            fos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// 优化加速版</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">// 一次读取多个字节，复制速度更快</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close(); <span class="comment">// 先释放输出流，再释放输入流</span></span><br><span class="line">        fis.close(); <span class="comment">// 因为咱们是读取一下在写出一下，如果读取完毕了，写出不一定完毕。但如果输出流用完了，输入流一定用完了。</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 记录一个结束时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符流">字符流</h1>
<p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储（<code>Unicod</code>三个字节、<code>GBK</code>两个字节）。所以<code>Java</code>提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 <strong>里面用到的各种方法使用步骤和字节流相似。</strong></p>
<h2 id="字符输入流-reader">字符输入流 Reader</h2>
<p><code>java.io.Reader</code>抽象类是表示用于字符输入流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的共性方法。</p>
<blockquote>
<p><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。 <code>public int read()</code>： 从输入流读取一个字符。 <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中 。</p>
</blockquote>
<h2 id="filereader类">FileReader类</h2>
<p><code>java.io.FileReader extends InputStreamReader extends Reader</code></p>
<p><code>FileReader</code> 文件字符输入流：把硬盘文件中的数据以字符的方式读取到内存中</p>
<h3 id="构造方法-4">构造方法</h3>
<ul>
<li><code>FileReader(File file)</code></li>
<li><code>FileReader(String fileName)</code></li>
</ul>
<p>参数：读取文件的数据源</p>
<ul>
<li><code>String fileName</code> ：文件的路径</li>
<li><code>File file</code>：一个文件</li>
</ul>
<p>作用：</p>
<ol type="1">
<li>创建一个<code>FileReader</code>对象</li>
<li>会把<code>FileReader</code>对象指向要读取的文件</li>
</ol>
<p><strong>使用步骤：</strong></p>
<ol type="1">
<li>创建<code>FileReader</code>对象，构造方法中绑定要读取的数据源</li>
<li>使用<code>FileReader</code>对象中的方法<code>read</code>读取文件</li>
<li>释放资源</li>
</ol>
<p>类似于<code>FileInputStream</code></p>
<h3 id="读取字符数据">读取字符数据</h3>
<ol type="1">
<li><code>int read()</code></li>
<li><code>int read(char[] cbuf)</code></li>
</ol>
<p>这俩方法我就不解释了，和字节输入流的<code>read</code>方法类似只是获取到的一个是字节，一个是字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Reader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建FileReader对象，构造方法中绑定要读取的数据源</span></span><br><span class="line">        <span class="comment">// 这个文件得是UTF-8编码，read读取的字符编码方式默认是UTF-8，两种码对应起来，才能不乱码</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo04\\a.txt"</span>);</span><br><span class="line">        <span class="comment">// 2. 使用FileReader对象中的方法read读取文件</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while ((len = fr.read()) != -1)&#123; // 读取的是字符，只不过是提升成int类型</span></span><br><span class="line"><span class="comment">//            System.out.print((char) len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 一次读取多个字符，用字符数组保存，提高效率</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len)); <span class="comment">// String类的构造方法，把字符数组的一部分转换为字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符输出流-writer">字符输出流 Writer</h2>
<p><code>java.io.Writer</code>抽象类是表示用于字符输出流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的共性方法。</p>
<blockquote>
<p><code>void write(int c)</code> 写入单个字符。 <code>void write(char[] cbuf)</code>写入字符数组。 <code>abstract  void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 <code>void write(String str)</code>写入字符串。 <code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 <code>void flush()</code>刷新该流的缓冲。 <code>void close()</code> 关闭此流，但要先刷新它。</p>
</blockquote>
<h2 id="filewriter类">FileWriter类</h2>
<p><code>java.io.FileWriter extends OutputStreamWriter extends Writer</code> <code>FileWriter</code>：文件字符输出流，把内存中的字符数据写入到文件中</p>
<h3 id="构造方法-5">构造方法</h3>
<p><code>FileWriter(File file)</code> <code>FileWriter(String fileName)</code></p>
<p>参数：写入数据的目的地</p>
<ul>
<li><code>String fileName</code>：文件的路径</li>
<li><code>File file</code>：文件</li>
</ul>
<p>作用：</p>
<ol type="1">
<li>创建一个 <code>FileWriter</code> 对象</li>
<li>根据构造方法中传递的文件/文件的路径，创建文件</li>
<li>会把<code>FileWriter</code>对象指向创建好的文件</li>
</ol>
<p><strong>字符输出流使用步骤：</strong></p>
<ol type="1">
<li>创建一个<code>FileWriter</code>对象，构造方法中绑定要写入数据的目的地</li>
<li>使用<code>FileWriter</code>中的方法<code>write</code>，把数据写入到内存缓冲区中（字符转换为字节的过程）</li>
<li>使用<code>FileWriter</code>中的方法<code>flush</code>，把内存缓冲区中的数据，刷新到文件中</li>
<li>释放资源（会先把内存缓冲区中的数据刷新到文件中，因此第 3 步有时可以省略）</li>
</ol>
<p>类似于<code>FileOutputStream</code></p>
<h3 id="基本写出数据">基本写出数据</h3>
<p><code>void write(int b)</code>：写出单个字符 <code>void write(char[] cbuf)</code>：写出字符数组 <code>void write(char[] cbuf, int off, int len)</code>： 写出字符数组的一部分 <code>void write(String str)</code>：写字符串 <code>void write(String str, int off, int len)</code>：写字符串的一部分</p>
<h3 id="关闭和刷新">关闭和刷新</h3>
<p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是<code>close</code> 方法关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<p><code>void flush()</code> ：刷新缓冲区，流对象可以<strong>继续使用</strong> <code>void close()</code>：先刷新缓冲区，然后通知系统释放资源，流对象<strong>不可以再被使用</strong>了</p>
<h4 id="续写和换行">续写和换行</h4>
<p>续写：在构造函数中加参数<code>boolean append</code> <code>FileWriter(File file, boolean append)</code> <code>FileWriter(String fileName, boolean append)</code></p>
<p>换行：使用换行符，详情见<strong>字节流</strong></p>
<p>上面三节内容和字节流部分极为相似，所以示例代码我整合着写成一块。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Writer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个FileWriter对象，构造方法中绑定要写入数据的目的地</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo04\\a.txt"</span>, <span class="keyword">true</span>); <span class="comment">// 续写开关打开，支持续写</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用FileWriter中的方法write，把数据写入到内存缓冲区中（字符转换为字节的过程）</span></span><br><span class="line">        <span class="comment">// 写单个字符</span></span><br><span class="line">        fw.write(<span class="number">97</span>); <span class="comment">// a 因为单位是字符，就要先把字符存到内存缓冲区，缓冲区将字符解码为字节，如果不调用flush，数据依然再缓冲区，不会写到目标文件中！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cs = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">        fw.write(cs); <span class="comment">// abcde</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写字符数组的一部分</span></span><br><span class="line">        fw.write(cs,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// bcd</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写字符串</span></span><br><span class="line">        fw.write(<span class="string">"刺客67"</span>); <span class="comment">// 刺客67</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写字符串的一部分</span></span><br><span class="line">        fw.write(<span class="string">"JOJO的黄金精神"</span>,<span class="number">5</span>,<span class="number">4</span>); <span class="comment">// 黄金精神</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写换行</span></span><br><span class="line">        fw.write(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中</span></span><br><span class="line">        fw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  刷新之后，流可以继续使用</span></span><br><span class="line">        fw.write(<span class="number">98</span>); <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 释放资源（会先把内存缓冲区中的数据刷新到文件中，因此第 3 步有时可以省略）</span></span><br><span class="line">        fw.close();</span><br><span class="line">        <span class="comment">// fw.write(99); 流已经关闭抛出IOException：Stream closed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于-字符字节-输入输出流的思考">关于 字符/字节 输入/输出流的思考：</h2>
<p>文件字节输出流这个过程就是：内存输入字节 --&gt; 字节写入文件。但是<code>write</code>传入的是<code>int</code>型的参数，忽略了高24位，直接写入低8位，为什么不直接传入<code>byte</code>型的参数呢？为什么这么设计？？？我搜了一下资料，还真在知乎上找到了相同的问题，（!(https://www.zhihu.com/question/39814712)）摘两个有意思的回答：</p>
<blockquote>
<p>这个问题要从JVM虚拟机与底层交互的方面去分析，所以我觉得这是Java语言和c语言类型定义导致的问题； 首先看Java中的函数定义：<code>private native void write(int b, boolean append) throws IOException;</code> 注意：是 <code>native</code> 方法 C语言中的定义：<code>int fputc(int ch,FILE *fp)</code> 我们看到两种语言中都是使用<code>int</code>类型，而不是其它，为什么呢？ 1、Java中有 <code>byte</code> 类型，C语言中没有 2、为什么不用<code>char</code>？java中<code>byte</code>到<code>char</code>需要一个强制转换，而 <code>int</code>不需要； 3、为什么不用<code>short</code>? 这个是32位CPU 4字节对齐的问题吧， 4、C语言中整型量和字符量可以通用；所以Java和C语言文件读写的通信，最佳类型就是<code>int</code>。</p>
</blockquote>
<p>大致意思就是，C语言中没有<code>byte</code>类型，所以用的参数<code>int</code>，而<code>Java</code>为了兼容<code>C</code>语言，做出了妥协</p>
<blockquote>
<p>因为<code>read()</code>方法会返回 0~255 以及 -1。所以<code>write()</code>最好是设计成与<code>read()</code>相匹配的模式。 我们还可以注意到<code>read(byte[])</code>方法也会返回一个<code>int</code>代表读取到的字节数，同样也可能返回-1代表已到达流末尾。所以这里不需要使用<code>int[]</code>，而是可以使用<code>byte[]</code>。 我想如果当初设计<code>read()</code>方法时，不是采用返回-1来代表流末尾，而是抛出一个异常<code>EOFException</code>的话，用<code>byte</code>也是完全可以的。</p>
</blockquote>
<p>我想了下，也是，我<code>read()</code>返回的不单是<code>byte</code>啊，如果读取到结束位置，<code>read</code>返回的会是<code>-1</code>，所以<code>read</code>返回的数据范围一定会比<code>byte</code>大<code>1</code>，那么我就得把<code>read</code>返回值设置成范围更大的<code>int</code>。</p>
<p>而且<code>read(byte[])</code>这种重载方法也很巧妙，正常来讲，如果我把读取到的字节都存入<code>byte[]</code>的话，又会出现上面说的，如果读取到结束符呢？？那不又要用-1来代替？这又要超<code>byte</code>的范围了，但是<code>read(byte[])</code>返回值设计成<strong>读取到的有效的字节个数</strong>，这就很有意思了，如果读取到结束符，我不存<code>byte[]</code>数组，而是统计一下读取到结束符前有几个字节数，把它返回，如果一个字节都没有读取到，返回<code>-1</code>。这样我的传入参数不需要是<code>int[]</code> 而是<code>byte[]</code>即可！</p>
<p>既然讲到了文件字节输入流的<code>read</code>，我们就接着<strong>编码问题</strong>在捋一捋文件字节输入流。读取文件内字节 --&gt; 字节传递给内存。但是，到这一步，你得到的就是一串字节，如果你想在控制台打印文件里到底是什么，就需要将字节再编码为字符。可以使用<code>new String(byte[] bytes)</code>将字节数组转换成字符串，这一步就要注意了，字符串默认用的<code>UTF-8</code>的编码表，而文件内的字节呢，是跟文件当初怎么写怎么存的有关。</p>
<p>举个例子，我用<code>GBK</code>编码格式保存了一个文件，里面存了<code>"你好"</code> 两个字，如果按照上面说的流程，那控制台得到的结果就乱码了。因为字符串构造方法使用的编码(<code>UTF-8</code>)和源文件的编码(<code>GBK</code>)不一样。当然也有解决办法，详情见<strong>转换流</strong></p>
<p>同理，文件字节输出流的<code>write</code>，如果我们使用字符串的<code>getBytes()</code>将字符串转换为字节，默认使用的也是<code>UTF-8</code>编码。 写出的文件如果用其他编码打开，也会乱码。</p>
<h1 id="io异常处理">IO异常处理</h1>
<p>在<code>JDK1.7</code>之前，我们可以使用<code>try..catch finally</code> 处理流中的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Writer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提高变量fw的作用域，如果放到try里面的话，finally里不能使用。</span></span><br><span class="line">        <span class="comment">// 变量在定义时可以没有值，但是使用的时候必须有值</span></span><br><span class="line">        <span class="comment">// 如果不赋值，并且fw在try块里赋值失败，那么fw就没有值，finally块里的代码就会报错</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能产生异常的代码</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"E:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo04\\b.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fw.write(<span class="string">"欧拉"</span> + i + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论程序是否出现异常，close必须执行</span></span><br><span class="line">            <span class="comment">// 如果fw创建失败，默认值null，null不能调用close，抛出NullPointerException</span></span><br><span class="line">            <span class="comment">// 所以在此添加一步判断来优化代码，如果是null，就不执行close</span></span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// close方法声明抛出了IOException，也需要用try...catch处理</span></span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看到，<code>try...catch finally</code> 格式处理输入输出流是多么的麻烦，如何优化？ <code>JDK7</code>的新特性，在<code>try</code>后面增加一个<code>()</code>，在括号中定义流对象。那么这个流对象的作用域，就在<code>try</code>中有效，<code>try</code>中代码执行完毕，会自动把流对象释放，不用写<code>finally</code>了</p>
<p><code>JDK9</code>的新特性，在<code>try</code>前面可以定义流对象，在<code>try</code>后边<code>()</code>中可以引入流对象的名称，在<code>try</code>代码执行完毕之后，流对象也可以释放掉，不用写<code>finally</code></p>
<p>拿之前图片复制的代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01JDK7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // JDK7 新特性 try后面加括号</span></span><br><span class="line"><span class="comment">        try (FileInputStream fis = new FileInputStream("C:\\我老婆.jpg");</span></span><br><span class="line"><span class="comment">             FileOutputStream fos = new FileOutputStream("D:\\我老婆.jpg")) &#123;</span></span><br><span class="line"><span class="comment">            int len = 0;</span></span><br><span class="line"><span class="comment">            byte[] bytes = new byte[1024];</span></span><br><span class="line"><span class="comment">            while ((len = fis.read(bytes)) != -1) &#123;</span></span><br><span class="line"><span class="comment">                fos.write(bytes, 0, len);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(e);</span></span><br><span class="line"><span class="comment">        &#125; // 不需要finally 不需要close try执行完自动释放资源</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK9 新特性 在try外面定义对象 注意定义对象的时候需要抛出 FileNotFoundException</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\我老婆.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\我老婆.jpg"</span>);</span><br><span class="line">        <span class="keyword">try</span> (fis;fos) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="属性集">属性集</h1>
<h2 id="概述-2">概述</h2>
<p><code>java.util.Properties extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;</code> <code>Properties</code> 类来表示一个持久的属性集。<code>Properties</code>可保存在流中或从流中加载。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<p><code>Properties</code> 是一个唯一和IO流相结合的集合</p>
<ul>
<li>可以使用<code>Properties</code>集合中的方法<code>store</code> 把集合中临时数据，持久化写入到硬盘中存储。</li>
<li>可以使用<code>Properties</code>集合中的方法<code>load</code> 把硬盘中保存的文件（键值对），读取到集合中使用。</li>
<li><code>Properties</code>集合是一个双列集合，<code>key</code>和<code>value</code>默认都是字符串。</li>
</ul>
<h2 id="properties类">Properties类</h2>
<h3 id="构造方法-6">构造方法</h3>
<ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法">基本的存储方法</h3>
<ul>
<li><code>Object setProperty(String key, String value)</code> ： 相当于Map集合中的<code>put</code></li>
<li><code>String getProperty(String key)</code> ：相当于Map集合中的<code>get</code></li>
<li><code>Set&lt;String&gt; stringPropertyNames()</code> ：相当于Map集合中的<code>keySet</code></li>
</ul>
<h3 id="与流相关的方法">与流相关的方法</h3>
<ul>
<li><code>void store(OutputStream out, String comments)</code></li>
<li><code>void store(Writer writer, String comments)</code></li>
</ul>
<p>参数： - <code>OutputStream out</code>： 字节输出流，不能写中文 - <code>Writer writer</code>：字符输出流，可以写中文 - <code>String comments</code>：注释，用来解释说明保存的文件是做什么用的，不能使用中文，会产生乱码，默认是<code>Unicode</code>编码，一般使用<code>""</code>空字符串</p>
<p>使用步骤： 1. 创建<code>Properties</code>集合对象，添加数据 2. 创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地 3. 使用<code>Properties</code>集合中的方法<code>store</code>，把集合中的临时数据持久化写入硬盘中存储 4. 释放资源</p>
<ul>
<li><code>public void load(InputStream inStream)</code></li>
<li><code>public void load(Reader reader)</code> 参数：
<ul>
<li>InputStream inStream：字节输入流，不能读取含有中文的键值对</li>
<li>Reader reader：字符输入流，能读取含有中文的键值对</li>
</ul></li>
</ul>
<p>使用步骤： 1. 创建Properties集合对象 2. 使用Properties集合对象中的方法load读取保存键值对的文件 3. 遍历Properties集合</p>
<p>注意： 1. 存储键值对的文件中，键与值默认的连接符号可以使用<code>=</code> 或 <code>空格</code> 2. 存储键值对的文件中，可以使用<code>#</code>进行注释，被注释的键值对，不会再被读取 3. 存储键值对的文件中，键与值默认都是字符串，不用再加引号</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Properties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//show01();</span></span><br><span class="line">        <span class="comment">//show02();</span></span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用Properties集合特有的方法遍历取出集合中的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Properties集合对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用setProperties在集合中添加数据</span></span><br><span class="line">        prop.setProperty(<span class="string">"乔斯达"</span>, <span class="string">"188"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"承太郎"</span>, <span class="string">"188"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"乔巴那"</span>, <span class="string">"188"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用stringPropertyNames()把Properties集合中的键取出，存储到一个Set集合中</span></span><br><span class="line">        <span class="comment">// 遍历Set集合，取出Properties集合的每一个键</span></span><br><span class="line">        Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            <span class="comment">// 使用getProperty(String key)通过key来获取value</span></span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">"-&gt;"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        store方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Properties集合对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用setProperties在集合中添加数据</span></span><br><span class="line">        prop.setProperty(<span class="string">"乔斯达"</span>, <span class="string">"188"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"承太郎"</span>, <span class="string">"188"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"乔巴那"</span>, <span class="string">"188"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo05\\a.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用Properties集合中的方法store，把集合中的临时数据持久化写入硬盘中存储</span></span><br><span class="line">        prop.store(fw, <span class="string">"save data"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        load方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Properties集合对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 2. 使用Properties集合对象中的方法load读取保存键值对的文件</span></span><br><span class="line">        prop.load(<span class="keyword">new</span> FileReader(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo05\\a.txt"</span>));</span><br><span class="line">        <span class="comment">// 3. 遍历Properties集合</span></span><br><span class="line">        Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="缓冲流">缓冲流</h1>
<h2 id="概述-3">概述</h2>
<p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<p><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> <strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></p>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统<code>IO</code>次数，从而提高读写的效率。</p>
<h2 id="字节缓冲输出流">字节缓冲输出流</h2>
<p><code>java.io.BufferedOutputStream extends OutputStream</code> <code>BufferedOutputStream</code> 字节缓冲输出流 继承了父类所有的共性方法</p>
<h3 id="构造方法-7">构造方法</h3>
<p><code>public BufferedOutputStream(OutputStream out)</code> <code>public BufferedOutputStream(OutputStream out, int size)</code></p>
<p>参数： - <code>OutputStream in</code>：字节输出流，我们可以传递<code>FileOutputStream</code>，缓冲流会给<code>FileOutputStream</code>增加一个缓冲区，提高FileOutputStream的写出效率。 - <code>int size</code>：指定内部缓冲区的大小，不指定就是默认大小。</p>
<h3 id="写出数据">写出数据</h3>
<p>步骤： 1. 创建一个<code>FileOutputStream</code>对象，构造方法中绑定要输出的目的地 2. 创建一个<code>BufferedOutputStream</code>对象，构造方法中传递<code>FileOutputStream</code>对象 3. 使用<code>BufferedOutputStream</code>对象中的方法<code>write</code>，把数据写入到内部缓冲区中 4. 使用<code>BufferedOutputStream</code>对象中的方法<code>flush</code>，把内部缓冲区中的数据，刷新到文件中 5. 释放资源（会先调用<code>flush</code>方法刷新，第 4 步可以省略）</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01BufferedOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个FileOutputStream对象，构造方法中绑定要输出的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo06\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//  2. 创建一个BufferedOutputStream对象，构造方法中传递FileOutputStream对象</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">// 3. 使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中</span></span><br><span class="line">        bos.write(<span class="string">"我把数据写入到内部缓冲区中"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4. 使用BufferedOutputStream对象中的方法flush，把内部缓冲区中的数据，刷新到文件中</span></span><br><span class="line">        bos.flush();</span><br><span class="line">        <span class="comment">// 5. 释放资源（会先调用flush方法刷新，第 4 步可以省略）</span></span><br><span class="line">        bos.close(); <span class="comment">// 不需要close掉fos，只要bos关闭，fos也就自动关闭了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字节缓冲输入流">字节缓冲输入流</h2>
<p><code>java.io.BufferedInputStream extends InputStream</code> <code>BufferedInputStream</code> 字节缓冲输入流</p>
<h3 id="构造方法-8">构造方法</h3>
<p><code>public BufferedInputStream(InputStream in)</code> <code>public BufferedInputStream(InputStream in, int size)</code></p>
<p>参数： - <code>InputStream in</code>：字节输入流，我们可以传递FileInputStream，缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream的写出效率。 - <code>int size</code>：指定内部缓冲区的大小，不指定就是默认大小。</p>
<h3 id="读取数据">读取数据</h3>
<p>步骤： 1. 创建<code>FileInputStream</code>对象 2. 创建<code>BufferedInputStream</code>对象，构造方法中传递<code>FileInputStream</code>对象 3. 使用<code>BufferedInputStream</code>对象的方法<code>read</code> 4. 释放资源</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02BufferedInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建FileInputStream对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo06\\a.txt"</span>);</span><br><span class="line">        <span class="comment">// 2. 创建BufferedInputStream对象，构造方法中传递FileInputStream对象</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        <span class="comment">// 3. 使用BufferedInputStream对象的方法read</span></span><br><span class="line">        <span class="comment">// 一次读一个字节</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while ((len = bis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次读多个字节</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符缓冲输出流">字符缓冲输出流</h2>
<p><code>java.io.BufferedWriter extends Writer</code> <code>BufferedWriter</code> 字节缓冲输出流</p>
<h3 id="构造方法-9">构造方法</h3>
<p><code>public BufferedWriter(Writer out)</code> <code>public BufferedWriter(Writer out, int size)</code></p>
<h3 id="特有成员方法">特有成员方法</h3>
<p><code>public void newLine()</code>: 写一个行分隔符，会根据不同的操作系统，获取不同的行分隔符。 相比之前要根据不同操作系统写不一样的换行符，这个显然简单得多。 <code>println</code>方法调用的换行就是用的<code>newLine</code></p>
<h3 id="写出数据-1">写出数据</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03BufferedWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo06\\a.txt"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">"欧拉"</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符缓冲输入流">字符缓冲输入流</h2>
<p><code>java.io.BufferedReader extends Reader</code> <code>BufferedReader</code> 字节缓冲输入流</p>
<h3 id="构造方法-10">构造方法</h3>
<p><code>public BufferedReader(Reader in)</code> <code>public BufferedReader(Reader in, int size)</code></p>
<h3 id="特有成员方法-1">特有成员方法</h3>
<p><code>public String readLine()</code>: 读取一行文本行。读取一行数据。通过下列字符之一即可认为某行已终止：换行（<code>'\n'</code>）、回车（<code>'\r'</code>）或回车后直接跟着换行（<code>"\r\n"</code>）</p>
<p>返回值：包含该行内容的字符串但不包含任何行终止符；如果已达到流末尾，则返回<code>null</code></p>
<h3 id="读取数据-1">读取数据</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04BufferedReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo06\\a.txt"</span>));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习文本排序">练习:文本排序</h2>
<p>请将文本信息恢复顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要用到正则表达式和<code>String</code>的<code>split</code> 方法，现在不会写也没关系。看看步骤思想就好。</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个集合用来保存读取的文本</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2. 创建缓冲流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo06\\a.txt"</span>)); <span class="comment">// 读取乱序文本所在的文件</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo06\\b.txt"</span>)); <span class="comment">// 保存排好序的文本的文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 读取文本，key存前面的序号；value存其余部分</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123; <span class="comment">// 通过newLine可以一行一行读取</span></span><br><span class="line">            <span class="comment">// split方法可以将一个字符串按照参数分成几个字符串并存在一个字符串数组中 每一行只有一个点，点前面是序号放到数组的第一个位置，剩下的放到数组第二个位置</span></span><br><span class="line">            String[] arr = line.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">// 把序号做key 其余做value 放到集合中</span></span><br><span class="line">            map.put(arr[<span class="number">0</span>],arr[<span class="number">1</span>]); <span class="comment">// key会根据序号自动排序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 遍历集合，重新组合写出</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            line =  key+<span class="string">"."</span>+value;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            <span class="comment">// 没写完集合中一条元素，记得换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="转换流">转换流</h1>
<h2 id="字符编码">字符编码</h2>
<p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)--字节(看不懂的)</p>
<p>解码:字节(看不懂的)--&gt;字符(能看懂的)</p>
<p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p><strong>编码表</strong>：生活中文字和计算机中二进制的对应规则</p>
<h2 id="字符集">字符集</h2>
<p><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有<code>ASCII</code>字符集、<code>GBK</code>字符集、<code>Unicode</code>字符集等。</p>
<p>当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：
<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul></li>
<li><strong>ISO-8859-1字符集</strong>：
<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul></li>
<li><strong>GBxxx字符集</strong>：
<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul></li>
<li><strong>Unicode字符集</strong> ：
<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：
<ol type="1">
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol></li>
</ul></li>
</ul>
<h2 id="编码引出的问题">编码引出的问题</h2>
<p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，项目中创建的文件都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取系统中创建的文本文件，如果我们创建文件时选择的编码是<code>GBK</code>（也叫做<code>ANSI</code>）编码，就会出现乱码。</p>
<h2 id="outputstreamwriter">OutputStreamWriter</h2>
<p>转换流<code>java.io.OutputStreamWriter extends Writer</code> ，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h3 id="构造方法-11">构造方法</h3>
<ul>
<li><code>OutputStreamWriter(OutputStream out)</code></li>
<li><code>OutputStreamWriter(OutputStream out, String charsetName)</code></li>
</ul>
<p>参数： - <code>OutputStream out</code>：字节输出流 - <code>String charsetName</code>：指定的编码表名称，不区分大小写</p>
<p>步骤： 1. 创建<code>OutputStreamWriter</code>对象 2. 使用<code>OutputStreamWriter</code>对象的<code>write</code>方法 3. 使用<code>OutputStreamWriter</code>对象的<code>flush</code>方法 4. 释放资源</p>
<h3 id="指定编码写出">指定编码写出</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01OutputStreamWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("day17-code\\src\\cn\\perdant\\day17\\demo07\\utf-8.txt"), "utf-8"); // 指定编码集 utf-8</span></span><br><span class="line">        <span class="comment">// OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("day17-code\\src\\cn\\perdant\\day17\\demo07\\utf-8.txt")); // 不写的话也默认是 utf-8</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo07\\gbk.txt"</span>),<span class="string">"gbk"</span>); <span class="comment">// 指定编码集 gbk</span></span><br><span class="line">        osw.write(<span class="string">"你好"</span>);</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inputstreamreader">InputStreamReader</h2>
<p><code>java.io.InputStreamReader extends Reader</code>，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受IDE的默认字符集。</p>
<h3 id="构造方法-12">构造方法</h3>
<ul>
<li><code>InputStreamReader(InputStream in)</code></li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code></li>
</ul>
<p><strong>注意事项：</strong>构造方法中指定的编码表要和文件的编码相同，否则会发生乱码</p>
<h3 id="指定编码读取">指定编码读取</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02InputStreamReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream("D:\\utf-8.txt"));  // 默认是utf-8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\gbk.txt"</span>),<span class="string">"gbk"</span>); <span class="comment">// 指定gbk编码</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换文件编码">转换文件编码</h2>
<p>将GBK编码的文本文件，转换为UTF-8编码的文本文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\gbk.txt"</span>), <span class="string">"gbk"</span>);</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\utf-8.txt"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            osw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于转换流的总结">关于转换流的总结</h2>
<p>其实你可以把<code>InputStreamReader</code>理解成<code>FileReader</code>的<strong>plus</strong>版本。对比一下二者</p>
<ul>
<li><code>FileReader</code>：读取文件，把文件内的字节以字节为单位传给<code>FileReader</code>，<code>FileReader</code>按照<strong>默认格式</strong>编码成字符，以字符为单位传给内存</li>
<li><code>InputStreamReader</code>：读取文件，把文件内的字节以字节为单位传给<code>InputStreamReader</code>，<code>InputStreamReader</code>按照<strong>指定格式</strong>编码成字符，以字符为单位传给内存</li>
</ul>
<p>其实他们二者底层都依靠了<code>FileInputStream</code>先来读取文件内的字节，但二者在将字节转换为字符这步有所不同。</p>
<p>我们再对比<code>InputStreamWriter</code>和<code>FileWriter</code></p>
<ul>
<li><code>FileWriter</code>：写出文件，把内存中的字符传给<code>FileWriter</code>，<code>FileWriter</code>按照<strong>默认格式</strong>解码成字节。以字节为单位传给文件</li>
<li><code>InputStreamWriter</code>：写出文件，把内存中的字符传给<code>InputStreamWriter</code>，<code>InputStreamWriter</code>按照<strong>指定格式</strong>解码成字节。以字节为单位传给文件</li>
</ul>
<p>同理，这二者都底层都依靠了<code>FileOutStream</code></p>
<blockquote>
<p>当然，<code>InputStreamReader</code>底层不单单可以使用 <code>FileInputStream</code>，任何<code>InputStream</code>的子类都可以，所以，<code>FileReader</code>仅仅是<code>InputStreamReader</code>构造时传入<code>FileInputStream</code>和<code>默认编码格式</code>的一种特例。这就是为什么<code>FileReader extends InputStreamReader</code></p>
</blockquote>
<h1 id="序列化">序列化</h1>
<h2 id="概述-4">概述</h2>
<p>我能不能把对象保存到文件中？不同于普通的写文件读文件，将对象写入文件以后，我们使用特定的读对象方法，返回的既不是字节也不是字符，而是一个对象<code>Object</code>。这样我们就可以直接使用这个对象的各种成员方法和变量</p>
<p><strong>写对象</strong></p>
<p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>
<p><strong>读对象</strong></p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p>
<h2 id="objectoutputstream">ObjectOutputStream</h2>
<p><code>java.io.ObjectOutputStream extends OutputStream</code> 对象的序列化流 把对象以流的方式写入到文件中保存</p>
<h3 id="构造方法-13">构造方法</h3>
<p><code>public ObjectOutputStream(OutputStream out)</code></p>
<h3 id="特有的成员方法">特有的成员方法</h3>
<p><code>void writeObject(Object obj)</code></p>
<p>使用步骤 1. 创建<code>ObjectOutputStream</code>对象,构造方法中传递字节输出流 2. 使用<code>ObjectOutputStream</code>对象中的方法<code>writeObject</code>把对象写入到文件中 3. 释放资源</p>
<h3 id="序列化操作">序列化操作</h3>
<ul>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ul>
<ol type="1">
<li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，当进行序列化和反序列化的时候，会检测类上是否又这个标记，有就可以序列化和反序列化，没有就会抛出<code>NotSerializableException</code></li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰，后面会介绍何为瞬态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  <span class="comment">// 想要序列化的类必须实现Serializable接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ObjectOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo08\\Person.txt"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"白金之星"</span>,<span class="number">25</span>)); <span class="comment">// 把一个Person对象写入到Person.txt了</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objectinputstream类">ObjectInputStream类</h2>
<p><code>ObjectInputStream</code>对象的反序列化流，把文件中保存的对象，以流的方式读取出来使用。</p>
<h3 id="构造方法-14">构造方法</h3>
<p><code>public ObjectInputStream(InputStream in)</code></p>
<h3 id="特有方法">特有方法</h3>
<p><code>public final Object readObject()</code></p>
<p>使用步骤 1. 创建<code>ObjectInputStream</code>对象 2. 使用<code>ObjectInputStream</code>对象中的方法<code>readObject</code> 3. 释放资源 4. 使用读取出来的对象（可以直接打印看看）</p>
<h3 id="反序列化操作">反序列化操作</h3>
<ul>
<li>一个对象要想反序列化，必须满足两个条件:</li>
</ul>
<ol type="1">
<li>类必须实现<code>Serializable</code>接口</li>
<li><strong>对于<code>JVM</code>可以反序列化对象，它必须是能够找到<code>class</code>文件的类。如果找不到该类的<code>class</code>文件，<code>readObject</code>方法会抛出一个 <code>ClassNotFoundException</code> 异常。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123; <span class="comment">// 除了IO异常，还有一个找不到Class文件异常</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo08\\Person.txt"</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        Person o1 = (Person) o; <span class="comment">// 把读取的对象类型强转为Person</span></span><br><span class="line">        System.out.println(o1.getName()+<span class="string">" "</span>+o1.getAge()); <span class="comment">// 可以直接调用对象的成员方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反序列化遇到的异常">反序列化遇到的异常</h3>
<p><strong>另外，当<code>JVM</code>反序列化对象时，能找到<code>class</code>文件，但是<code>class</code>文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong></p>
<p>缕一缕上面的过程：</p>
<ol type="1">
<li>先对<code>Person</code>类的实例做一个序列化写入<code>Person.txt</code>文件</li>
<li>修改<code>Person</code>类</li>
<li>对<code>Person.txt</code>文件做一个反序列化</li>
<li>抛出异常<code>InvalidClassException</code></li>
</ol>
<p><strong>分析产生异常的原因：</strong></p>
<ol type="1">
<li><p>当定义好<code>Person</code>类之后，<code>Person.java</code>文件会通过<code>javac</code>编译成一个<code>Person.class</code>文件，这时<code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>Person.class</code>会有自己特有的一个序列版本号</p></li>
<li><p>当<code>Person</code>类实例序列化写入<code>Person.txt</code>文件之后，<code>Person.txt</code>会生成一个和<code>Person.class</code>相同的序列版本号</p></li>
<li><p>修改<code>Person</code>类之后，会重新编译新的<code>Person.class</code>文件。序列版本号也随之<strong>改变</strong> &gt; 并不是所有的修改都会让版本序列号改变。我简单的试了一下，修改类中的某些字符串内容不会导致版本号改变，但是修改成员变量的访问权限会导致版本号改变。</p></li>
<li><p>对<code>Person.txt</code>做反序列化时，会比较<code>Person.txt</code>与<code>Person.class</code>（已经改变了）文件的序列版本号是否相同，若相同，可以进行反序列化，若不同，抛出异常。</p></li>
</ol>
<p>如何解决此问题：</p>
<ul>
<li>我只要让修改后的<code>Person.class</code>文件不会改变序列版本号即可。那我们自己给它指定一个不可变的序列版本号可以吗？</li>
<li>在定义类的时候，我们添加一个成员变量 <code>serialVersionUID</code>并把它用<code>static final</code>修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// private int age;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age; <span class="comment">// 无论我怎么修改，都可以成功的反序列化</span></span><br></pre></td></tr></table></figure>
<h2 id="关于静态-static">关于静态 static</h2>
<p>静态优先于非静态加载到内存中（静态优先于对象进入到内存中） 所以被<code>static</code>修饰的成员变量<strong>不能被序列化</strong>，会保留它的默认值。序列化的都是对象。</p>
<h2 id="关于瞬态-transient">关于瞬态 transient</h2>
<p>被<code>transient</code>修饰的成员变量，<strong>不能被序列化</strong>， 它的作用就是，当你不想序列化对象中的某个特定的成员变量时，使用<code>transient</code>修饰它。</p>
<p><code>transient</code>和<code>static</code>修饰的成员变量都是不能序列化，但是在解决上面的版本号不一致问题时，不能用<code>transient</code>只能用<code>static</code>，说明二者还是有区别的。</p>
<h2 id="详细讨论static与transient的区别">详细讨论static与transient的区别</h2>
<p>结合代码来分析二者区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的整个JOJO类</span></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOJO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">42L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String standName;</span><br><span class="line">    ...构造方法，set get toString都省略不贴在这里了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticTransient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test-code\\src\\cn\\perdant\\test\\demo03\\JoJo.txt"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Jojo(<span class="string">"承太郎"</span>,<span class="string">"白金之星"</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticTransient2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test-code\\src\\cn\\perdant\\test\\demo03\\JoJo.txt"</span>));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        Jojo jojo = (Jojo) obj;</span><br><span class="line">        System.out.println(jojo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用<code>static</code>修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOJO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">42L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String standName = <span class="string">"GoldExperience"</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述序列化反序列化后结果：<code>JOJO{name='承太郎', standName='GoldExperience'}</code></p>
<p><code>static</code>是类的变量，不是对象的，所以在序列化的时候，不会和序列化的变量一起写入文件，但此变量已经早于序列化和反序列化被加载到内存中去了，所以在反序列化的时候，静态变量仍存在，不过是类定义是的初始赋值。</p>
<p><strong>个人见解：</strong></p>
<p>这里再仔细讲一下，我在写demo的时候发现，如果我把序列化和反序列化的代码写道一起，在一起运行的时候，得到的结果是<code>JOJO{name='承太郎', standName='白金之星'}</code></p>
<p>这是因为，如果你是分开写的，那么在序列化时，<code>static</code>修饰的变量没有序列化，而是在序列化开始之前就加载到内存的方法区中<code>'GoldExperience'</code>，但是在序列化时调用了构造方法，并且构造方法中将静态变量修改成<code>'白金之星'</code>，方法区中的静态变量值已经变了。但是你是分开写的，所以这个程序运行完，内存也已经释放了。再看反序列化</p>
<p>反序列化时，首先重新加载<code>JOJO</code>类，内存的方法区中的<code>static</code>修饰的变量仍是类定义的时候赋予的值<code>'GoldExperience'</code>，然后进行反序列化，读对象，对象中的<code>static</code>修饰的变量值是不在文件中的，它是在内存的方法区中的，所以去方法区中找，找到了<code>'GoldExperience'</code></p>
<p>如果把上面序列化和反序列化写在一起的话，可以看到，内存不会有释放重新加载这一步，那么内存方法区里的<code>'GoldExperience'</code>在序列化的时候就被修改成了<code>'白金之星'</code>，而反序列化的时候，再去内存方法区找静态变量调用的时候，得到的就是<code>'白金之星'</code>了</p>
<p>再看用<code>transient</code>修饰的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOJO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">42L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String standName = <span class="string">"GoldExperience"</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述序列化反序列化后结果：<code>JOJO{name='承太郎', standName='null'}</code></p>
<p><code>transient</code>修饰的变量不会序列化，是完全不会写入文件又因为它不是静态变量也不会写入方法区，相当于此变量从来未被赋值，所以调用此变量时返回的是默认值<code>null</code></p>
<h2 id="练习序列化集合">练习：序列化集合</h2>
<ol type="1">
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义一个存储Person对象的ArrayList集合</span></span><br><span class="line">        ArrayList&lt;Person&gt;  list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2. 往ArrayList集合中存储Person对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"马里奥"</span>, <span class="number">35</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"林克"</span>, <span class="number">22</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"塞尔达"</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="comment">//3. 创建一个序列化流对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo08\\List.txt"</span>));</span><br><span class="line">        <span class="comment">// 4. 对集合序列化</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">// 5. 创一个反序列化对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo08\\List.txt"</span>));</span><br><span class="line">        <span class="comment">// 6. 对集合反序列化</span></span><br><span class="line">        Object objList = ois.readObject();</span><br><span class="line">        <span class="comment">// 7. 把Object类型集合转换为ArrayList类型</span></span><br><span class="line">        ArrayList&lt;Person&gt; arrayList = (ArrayList&lt;Person&gt;)objList;</span><br><span class="line">        <span class="comment">// 8. 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Person p : arrayList) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 9. 释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打印流">打印流</h1>
<h2 id="概述-5">概述</h2>
<p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h2 id="printstream">PrintStream</h2>
<p><code>java.io.PrintStream extends OutputStream</code> （字节）打印流</p>
<p><code>PrintStream</code> 为其他输出流添加了功能，使他们能够方便地打印各种数据值表示形式</p>
<p><code>PrintStream</code>特点：</p>
<ol type="1">
<li>只负责数据的输出，不负责数据的读取</li>
<li>永远不会抛出<code>IOException</code> 但是会抛出 <code>FileNotFoundException</code></li>
<li>有特有的方法,<code>print,println</code>,参数可以是任意类型的值</li>
</ol>
<h3 id="构造方法-15">构造方法</h3>
<p><code>public PrintStream(String fileName)</code> <code>public PrintStream(OutputStream out)</code> <code>public PrintStream(File file)</code></p>
<p>注意：</p>
<ul>
<li>如果使用继承父类的<code>write</code>方法写数据，那么查看数据的时候会查询编码表 97 - a</li>
<li>如果使用自己特有的<code>print,println</code>方法写数据，写的数据原样输出 97 - 97</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01PrintStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"D:\\IdeaProjects\\basic-code\\day17-code\\src\\cn\\perdant\\day17\\demo09\\Print.txt"</span>);</span><br><span class="line">        ps.write(<span class="number">97</span>); <span class="comment">// a</span></span><br><span class="line">        ps.println(<span class="number">97</span>); <span class="comment">// 97</span></span><br><span class="line">        ps.println(<span class="string">"欧拉"</span>); <span class="comment">// 欧拉</span></span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改变打印流向">改变打印流向</h3>
<p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个"小把戏"，改变它的流向。</p>
<p>使用<code>System.setOut</code>方法改变输出语句的目的地改为参数中传递的打印流的目的地 <code>static void setOut(PrintStream out)</code> 重新分配“标准”输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02PrintStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"控制台输出"</span>);</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"day17-code\\src\\cn\\perdant\\day17\\demo09\\Print.txt"</span>);</span><br><span class="line">        System.setOut(ps); <span class="comment">// 把输出语句的目的地改变为打印流的目的地</span></span><br><span class="line">        System.out.println(<span class="string">"Print.txt输出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.11.23</p>
<h1 id="网络编程入门">网络编程入门</h1>
<h2 id="软件结构">软件结构</h2>
<ul>
<li><p><strong>C/S结构</strong> ：全称为<code>Client/Server</code>结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</p></li>
<li><p><strong>B/S结构</strong> ：全称为<code>Browser/Server</code>结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p></li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="网络通信协议">网络通信协议</h2>
<ul>
<li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p></li>
<li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p></li>
</ul>
<p>TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。</p>
<ul>
<li>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li>
<li>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li>
<li>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li>
<li>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li>
</ul>
<h2 id="协议分类">协议分类</h2>
<p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(<code>User Datagram Protocol</code>)。<code>UDP</code>是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<ul>
<li><p>由于使用<code>UDP</code>协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用<code>UDP</code>协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p></li>
<li><p>但是在使用<code>UDP</code>协议传送数据时，由于<code>UDP</code>的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用<code>UDP</code>协议。</p></li>
<li><p>数据被限制在64kb以内，超出这个范围就不能发送了。(数据报(Datagram):网络传输的基本单位 )</p></li>
</ul></li>
<li><p><strong>TCP</strong>：传输控制协议 (<code>Transmission Control Protocol</code>)。<code>TCP</code>协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<ul>
<li><p>在<code>TCP</code>连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p></li>
<li><p><strong>三次握手</strong>：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。</li>
</ul></li>
<li><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，<code>TCP</code>协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p></li>
</ul></li>
</ul>
<h2 id="网络编程三要素">网络编程三要素</h2>
<h3 id="协议">协议</h3>
<ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="ip地址">IP地址</h3>
<ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称<code>IP</code>。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p><code>IPv4</code>：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li>
<li><p><code>IPv6</code>：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p></li>
</ul>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 空格 IP地址</span><br></pre></td></tr></table></figure>
<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 这两个都代表当前计算机的<code>ip</code></li>
</ul>
<h3 id="端口号">端口号</h3>
<p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>举个例子，电脑a上的qq连接电脑b上的qq，电脑a通过IP地址找到电脑b，但是b上除了qq还有很多其他软件比如飞秋、MSN等，如果我从电脑a上qq发送的消息传到了MSN上是没有任何意义的。那么我如何精确找到我想要传输到的进程呢？需要给每个进程分配一个端口，从而来区分各个进程。</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><p><strong>端口号：</strong>是一个逻辑端口，无法直接看到，可以使用一些软件查看端口号。当我们使用网络软件，一打开，操作系统就会为网络软件分配一个随机得端口号。或者，在打开软件的同时和系统要一个指定得端口号</p></li>
<li><p><strong>用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</p></li>
<li><p>常见端口：</p>
<ol type="1">
<li>网络端口：80</li>
<li>数据库 mysql：3306 Oracle：1521</li>
<li>Tomcat服务器：8080</li>
</ol></li>
</ul>
<p><strong>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</strong></p>
<h1 id="tcp通信程序">TCP通信程序</h1>
<h2 id="概述-6">概述</h2>
<p><code>TCP</code>通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（<code>Client</code>）与服务端（<code>Server</code>）。是面向连接的通信，客户端和服务器端必须经过<strong>3次握手</strong>，建立逻辑连接，才能通信安全。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol type="1">
<li><strong>服务器端先启动</strong>，服务器端不会主动的请求客户端，必须使用客户端请求服务器端</li>
<li>客户端和服务器端就会建立一个逻辑连接，而这个链接中包含一个对象，这个对象就是<code>IO</code>对象</li>
<li>客户端和服务器端就可以使用<code>IO</code>对象进行通信，通信数据不仅仅是字符，所以<code>IO</code>对象是<strong>字节流</strong>对象</li>
<li>客户端与服务器端进行一次数据交互，需要<strong>4个<code>IO</code>流对象</strong></li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol type="1">
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<p>服务器端必须明确两件事情： 1. 多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互 在服务器端有一个方法，叫<code>accept</code>客户端获取到请求的客户端对象<code>Socket</code> 2. 多个客户端同时和服务器进行交互，就需要使用多个<code>IO</code>流对象 服务器是没有<code>IO</code>流的，服务器可以获取到请求的客户端对象<code>Socket</code>,使用每个客户端<code>Socket</code>中提供的<code>IO</code>流和客户端进行交互: - 服务器使用客户端的字节输入流，读取客户端发送的数据 - 服务器使用客户端的字节输出流，给客户端回写数据 简而言之：<strong>服务器使用客户端的流和客户端交互</strong></p>
<h2 id="socket类">Socket类</h2>
<p><code>java.net.Socket</code> 类：该类实现客户端<strong>套接字</strong></p>
<blockquote>
<p>套接字指的是两台设备之间通讯的端点。个人理解：套接字就是 协议+IP地址+端口号 有了这三者，网络通信才能确定连接的两端。</p>
</blockquote>
<h3 id="构造方法-16">构造方法</h3>
<p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的<code>host</code>是<code>null</code> ，则相当于指定地址为回送地址。</p>
<p>参数： <code>String host</code>：服务器主机的名称/服务器的IP地址 <code>int port</code>：服务器的端口号</p>
<blockquote>
<p>回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
<h3 id="成员方法">成员方法</h3>
<ul>
<li><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。
<ul>
<li>如果此<code>Scoket</code>具有相关联的通道，则生成的<code>InputStream</code>的所有操作也关联该通道。</li>
<li>关闭生成的<code>InputStream</code>也将关闭相关的<code>Socket</code></li>
</ul></li>
<li><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。
<ul>
<li>如果此<code>Scoket</code>具有相关联的通道，则生成的<code>OutputStream</code>的所有操作也关联该通道。</li>
<li>关闭生成的<code>OutputStream</code>也将关闭相关的<code>Socket</code></li>
</ul></li>
<li><code>public void close()</code> ：关闭此套接字。
<ul>
<li>一旦一个<code>Socket</code>被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的<code>InputStream</code>和<code>OutputStream</code></li>
</ul></li>
<li><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。
<ul>
<li>有时候我不想关闭整个<code>Socket</code>，我只想关闭<code>Socket</code>获取到的输出流。</li>
<li>任何先前写出的数据将被发送，随后终止输出流。</li>
</ul></li>
</ul>
<h3 id="客户端实现步骤">客户端实现步骤</h3>
<ol type="1">
<li>创建一个客户端对象<code>Socket</code>，构造方法绑定服务器的IP地址和端口号</li>
<li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流<code>OutputStream</code>对象</li>
<li>使用网络字节输出流<code>OutputStream</code>对象中的方法<code>write</code>，给服务器发送数据</li>
<li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流<code>InputStream</code>对象</li>
<li>使用网络字节输入流<code>InputStream</code>对象中的方法<code>read</code>，读取服务器回写的数据</li>
<li>释放资源（只需要关闭<code>Socket</code>即可）</li>
</ol>
<p><strong>注意：</strong></p>
<ol type="1">
<li>客户端和服务器端进行交互，必须使用<code>Socket</code>中<code>getXXXX</code>提供的网络流，不要使用直接创建的流对象</li>
<li>当我们创建客户端对象<code>Socket</code>的时候，它就会去请求服务器和服务器经过3次握手，建立连接通路。这时，如果服务器没有启动，那么就会抛出<code>ConnectException</code>异常；如果服务器已经启动，那么就可以进行交互。</li>
</ol>
<h2 id="serversocket类">ServerSocket类</h2>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-17">构造方法</h3>
<p><code>public ServerSocket(int port)</code> ：使用该构造方法在创建<code>ServerSocket</code>对象时，就可以将其绑定到一个指定的端口上</p>
<p>参数：<code>int port</code>：端口号，服务器端<code>ServerSocket</code>侦听该端口，一旦有客户端向该端口发送数据，服务器端就可以接收到</p>
<h3 id="成员方法-1">成员方法</h3>
<p>服务器端只有一个，但是客户端可以有多个，所以服务器端必须明确一件事情，必须得知道是哪个客户端请求的服务器，所以首先使用<code>accept</code>方法获取到请求的客户端对象<code>Socket</code></p>
<p><code>public Socket accept()</code> ：<strong>侦听</strong>并接受连接，返回一个新的<code>Socket</code>对象，用于和客户端实现通信。该方法会一直<strong>阻塞</strong>直到建立连接。</p>
<blockquote>
<p>所谓阻塞，就是既不继续向下运行，也不抛出异常终止程序，处在一个程序仍在运行但不向下运行的等待状态</p>
</blockquote>
<h3 id="服务器端实现步骤">服务器端实现步骤</h3>
<ol type="1">
<li>创建服务器<code>ServerSocket</code>对象和系统要指定的端口</li>
<li>使用<code>ServerSocket</code>对象中的方法<code>accept</code>，获取到请求的客户端<code>Socket</code>对象</li>
<li>使用<code>Socket</code>对象中的方法<code>getInputStream()</code>获取网络字节输入流<code>InputStream</code>对象</li>
<li>使用网络字节输入流<code>InputStream</code>对象中的方法<code>read</code>，读取客户端发送的数据</li>
<li>使用<code>Socket</code>对象中的方法<code>getOutputStream()</code>获取网络字节输出流<code>OutputStream</code>对象</li>
<li>使用网络字节输出流<code>OutputStream</code>对象中的方法<code>write</code>，给客户端回写数据</li>
<li>释放资源（<code>ServerSocket</code>，<code>Socket</code>都要关闭）</li>
</ol>
<h2 id="简单的tcp网络程序">简单的TCP网络程序</h2>
<h3 id="tcp通信分析">TCP通信分析</h3>
<ol type="1">
<li>服务端启动,创建<code>ServerSocket</code>对象，等待连接。</li>
<li>客户端启动,创建<code>Socket</code>对象，请求连接。</li>
<li>服务端接收连接,调用<code>accept</code>方法，并返回一个<code>Socket</code>对象。</li>
<li>客户端<code>Socket</code>对象，获取<code>OutputStream</code>，向服务端写出数据。</li>
<li>服务端<code>Scoket</code>对象，获取<code>InputStream</code>，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6" type="1">
<li>服务端<code>Socket</code>对象，获取<code>OutputStream</code>，向客户端回写数据。</li>
<li>客户端<code>Scoket</code>对象，获取<code>InputStream</code>，解析回写数据。</li>
<li>客户端释放资源，断开连接。</li>
<li><del>服务端释放资源</del>（为了让服务器继续接收其他客户端发来的数据，通常不需要执行此步）</li>
</ol>
<h3 id="tcp通信实现">TCP通信实现</h3>
<p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    TCP通信的服务器端：接收客户端的请求，读取客户端发送的数据，给客户端回写数据</span></span><br><span class="line"><span class="comment">    表示服务器的类：java.net.ServerSocket：此类实现服务器套接字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建服务器ServerSocket对象和系统要指定的端口</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">// 5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 6. 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</span></span><br><span class="line">        os.write(<span class="string">"收到，谢谢"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 7. 释放资源（Socket，ServerSocket）</span></span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    TCP通信的客户端：向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据</span></span><br><span class="line"><span class="comment">    表示客户端的类：java.net.Socket</span></span><br><span class="line"><span class="comment">    套接字：包含了IP地址和端口号的网络单位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>); <span class="comment">// 此ip是本机ip，端口随便写一个</span></span><br><span class="line">        <span class="comment">// 2. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</span></span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 5. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">// 6. 释放资源（Socket）</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行服务器端，在运行客户端。服务器端的控制台打印：“你好服务器”，然后程序运行结束，客户端的控制台打印：“收到，谢谢” ，然后程序运行结束</p>
<h1 id="综合案例">综合案例</h1>
<h2 id="文件上传案例">文件上传案例</h2>
<p>客户端读取本地文件，把文件上传到服务器，服务器再把上传的文件保存到服务器的硬盘上</p>
<p>这里我们还是用之前<strong>IO流章节图片复制练习</strong>所使用的我老婆的图片，把我们本地计算机既当作客户端，又当作服务器端，要求读取<code>C:\\我老婆.jpg</code>，然后上传给服务器，服务器将图片保存到<code>D:\\upload</code>文件夹下</p>
<h3 id="文件上传分析">文件上传分析</h3>
<ol type="1">
<li>客户端<code>new</code>本地字节输入流，从硬盘读取文件数据到程序中。</li>
<li>客户端<code>get</code>网络字节输出流，写出文件数据到服务端。</li>
<li>服务端<code>get</code>网络字节输入流，读取文件数据到服务端程序。</li>
<li>服务端<code>new</code>本地字节输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<blockquote>
<p>至此已经完成：客户端读取本地文件，上传给服务器端，服务器端把文件写出到服务器文件</p>
</blockquote>
<blockquote>
<p>接下来是服务器向客户端写回“上传成功”信息</p>
</blockquote>
<ol start="5" type="1">
<li>服务端<code>get</code>网络字节输出流，给客户端回写一个“上传成功”</li>
<li>客户端<code>get</code>网络字节输入流，读取服务端回写的数据</li>
<li>释放资源</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol type="1">
<li>客户端和服务器端和本地硬盘进行读写，需要使用自己创建的字节流对象（本地流）</li>
<li>客户端和服务器之间进行读写，必须使用<code>Socket</code>中提供的字节流对象（网络流）</li>
<li>文件上传的原理，就是文件的复制，明确数据源和数据的目的地</li>
</ol>
<h4 id="基本实现">基本实现</h4>
<p><strong>服务端实现：</strong></p>
<ol type="1">
<li>创建一个服务器<code>ServerSocket</code>对象，和系统要指定的端口号</li>
<li>使用<code>ServerSocket</code>对象中的方法<code>accept</code>，获取到请求的客户端<code>Socket</code>对象</li>
<li>使用<code>Socket</code>对象中的方法<code>getInputStream</code>，获取到网络字节输入流<code>InputStream</code>对象</li>
<li>判断<code>D:\\upload</code>文件夹是否存在，不存在则创建</li>
<li>创建一个本地字节输出流<code>FileOutputStream</code>对象，构造方法中绑定要输出的目的地</li>
<li>使用网络字节输入流<code>InputStream</code>对象中的方法<code>read</code>，读取客户端上传的文件</li>
<li>使用本地字节输出流<code>FileOutputStream</code>对象中的方法<code>write</code>，把读取到的文件保存到服务器硬盘上</li>
<li>使用<code>Socket</code>对象中的方法<code>getOutputStream</code>，获取到网络字节输出流<code>OutputStream</code>对象</li>
<li>使用网络字节输出流<code>OutputStream</code>对象的<code>write</code>方法，给客户端回写"上传成功"</li>
<li>释放资源（<code>FileOutputStream</code>，<code>Socket</code>，<del><code>ServerSocket</code></del> 为了继续侦听其他客户端发来的请求，一般不关闭<code>ServerSocket</code>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个服务器ServerSocket对象，和系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 3. 使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4. 判断D:\\upload文件夹是否存在，不存在则创建</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\upload"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file+<span class="string">"\\我老婆.jpg"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 6. 使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件</span></span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 7. 使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器硬盘上</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8. 使用Socket对象中的方法getOutputStream，获取到网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 9. 使用网络字节输出流OutputStream对象的write方法，给客户端回写"上传成功"</span></span><br><span class="line">        os.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 10. 释放资源（FileOutputStream，Socket，ServerSocket）</span></span><br><span class="line">        fos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端实现：</strong></p>
<ol type="1">
<li>创建一个本地字节输入流<code>FileInputStream</code>对象，构造方法中绑定要读取的数据源</li>
<li>创建一个客户端<code>Socket</code>对象，构造方法中绑定服务器的IP地址和端口号</li>
<li>使用<code>Socket</code>中的方法<code>getOutputStream</code>，获取网络字节输出流<code>OutputStream</code>对象</li>
<li>使用本地字节输入流<code>FileInputStream</code>对象中的方法<code>read</code>，读取本地文件</li>
<li>使用网络字节输出流<code>OutputStream</code>对象中的方法<code>write</code>，把读取到的文件上传到服务器</li>
<li>使用<code>Socket</code>中的方法<code>getInputStream</code>，获取网络字节输入流<code>InputStream</code>对象</li>
<li>使用网络字节输入流<code>InputStream</code>对象中的方法<code>read</code>，读取服务器端回写的对象</li>
<li>释放资源（<code>FileInputStream</code>,<code>Socket</code>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\我老婆.jpg"</span>);</span><br><span class="line">        <span class="comment">//  2. 创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 4. 使用本地字节输入流FileInputStream对象中的方法read，读取本地文件</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!= -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 5. 使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器</span></span><br><span class="line">            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写一个终止标记 这个很重要 下面会细讲</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">// 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 7. 使用网络字节输入流InputStream对象中的方法read，读取服务器端回写的对象</span></span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes))!= -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8. 释放资源（FileInputStream,Socket）</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>这里我们要重点套路上面<strong>客户端实现</strong>中的第23行语句，如果不在这里加一个<code>shutdownOutput()</code>，我们会发现，文件已经写入到服务器的文件夹中了，但是客户端的控制台没有打印“上传成功”，而且服务器和客户端的程序都没有停止运行。这说明程序运行到某一处之后处于了<strong>阻塞</strong>状态。是哪里呢？下面我们从头捋一捋：</p>
<ol type="1">
<li>首先运行服务器端，服务器创建<code>ServerSocket</code>对象，处于侦听状态</li>
<li>然后运行客户端，创建<code>FileInputStream</code>对象和<code>Socket</code>对象中的方法<code>getOutputStream</code>获取<code>OutputStream</code>对象</li>
<li>客户端使用<code>FileInputStream</code>对象读取图片，使用<code>OutputStream</code>对象将图片写出给服务器，<strong>采用的循环读取，终止条件是读取到结束符时终止，但是这样写入的字节是不包含终止符的</strong></li>
<li>服务器端<code>accept</code>方法获取到请求的客户端<code>Socket</code>对象，并使用<code>getInputStream</code>获取<code>InputStream</code>对象</li>
<li>服务器端使用<code>InputStream</code>对象读取客户端传来的字节，使用<code>FileOutputStream</code>对象写出到服务器文件</li>
<li>同样是采用与第3步相同的循环读取，但是<strong>从客户端传来的字节是不含终止符的，所以读取的循环是一直不会终止的，所以在这里会处于阻塞状态，程序一直循环读取，一直循环写出，而后面的代码无法继续执行</strong></li>
</ol>
<p>因为程序一直在读取写入，所以程序结果会变成图片上传复制成功但程序没有终止，而且后续的服务器写回客户端的信息也没有打印，为了解决这个问题，我们需要使用<code>shutdownOutput()</code>方法，这个方法可以关闭<code>Socket</code>的<code>OuputStream</code>流，并且在写出的字节最后加一个终止符。这样服务器端的循环读取就会在读取到结束符时停止读取。让程序可以继续向下进行。</p>
<h3 id="文件上传优化分析">文件上传优化分析</h3>
<ol type="1">
<li><strong>文件名称写死的问题</strong></li>
</ol>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fileName = <span class="string">"perdant"</span>+ System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">".jpg"</span>; <span class="comment">// 一般格式是域名+时间+随机书+文件后缀</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在网上下载下来的文件名一般都是很长一串数字，往往就是采用了这种命名方法，这样每次下载下来的相同的文件，名字却往往不一样</p>
</blockquote>
<ol start="2" type="1">
<li><strong>循环接收的问题</strong></li>
</ol>
<p>服务端，只保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 让服务器一直处于监听状态 写一个死循环 有一个客户端上传文件，就保存一个文件。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">           ... <span class="comment">// 中间和之前的代码一样 省略不写了 </span></span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// server.close(); 服务器一直是监听状态，不需要关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>效率问题</strong></li>
</ol>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我们把上面的所有优化（都是针对服务器端的）放入之前的代码中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个服务器ServerSocket对象，和系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象</span></span><br><span class="line">        <span class="comment">// 让服务器一直处于监听状态 写一个死循环 有一个客户端上传文件，就保存一个文件。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="comment">// 使用多线程技术，有一个客户端上传文件，就开启一个线程，完成文件上传</span></span><br><span class="line">            <span class="comment">// 3. 使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// run方法不能声明抛出异常，只能try catch</span></span><br><span class="line">                    <span class="comment">// 重写run方法，用来完成文件的上传</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        <span class="comment">// 4. 判断d:\\upload文件夹是否存在，不存在则创建</span></span><br><span class="line">                        File file = <span class="keyword">new</span> File(<span class="string">"d:\\upload"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                            file.mkdir();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 5. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地</span></span><br><span class="line">                        <span class="comment">// 自定义文件名,每次运行都会得到不同的文件名</span></span><br><span class="line">                        String fileName = <span class="string">"perdant"</span>+ System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">".jpg"</span>;</span><br><span class="line">                        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file+<span class="string">"\\"</span>+fileName);</span><br><span class="line">                        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="comment">// 6. 使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件</span></span><br><span class="line">                        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// 7. 使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器硬盘上</span></span><br><span class="line">                            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 8. 使用Socket对象中的方法getOutputStream，获取到网络字节输出流OutputStream对象</span></span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line">                        <span class="comment">// 9. 使用网络字节输出流OutputStream对象的write方法，给客户端回写"上传成功"</span></span><br><span class="line">                        os.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                        <span class="comment">// 10. 释放资源（FileOutputStream，Socket，ServerSocket）</span></span><br><span class="line">                        fos.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// server.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟bs服务器扩展知识点">模拟B/S服务器(扩展知识点)</h2>
<h3 id="浏览器端服务器端分析">浏览器端服务器端分析</h3>
<p>在网络编程章节一开始，我们就讲过，除了<code>C/S</code>结构，还有一种<code>B/S</code>结构，就是浏览器与服务器连接的结构，和<code>C/S</code>结构类似，只不过把客户端换成了浏览器，而之间交互的数据往往是<code>html</code>文件。下面我来简单的捋一捋过程 然后写一个<code>demo</code>，因为里面用到了<code>html</code>文件，所以这里的代码你们可以自己先找一个<code>html</code>文件，再来复现</p>
<ol type="1">
<li>浏览器里输入一个地址</li>
<li>服务器接收到浏览器发来的请求，根据请求的内容，解析出浏览器想要访问的文件的地址</li>
<li>服务器读取文件并向浏览器回写（一般不止一个<code>htm</code>l文件，我用一个<code>web</code>文件夹储存了所有与网页有关的文件）</li>
<li>浏览器中可以把这个<code>html</code>文件以网页的形式显示出来</li>
</ol>
<p>我们之前的<strong>客户端就是现在的浏览器</strong>，相比<code>C/S</code>，<strong>B/S只需要创建服务器端</strong>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个服务器SeverSocket对象，端口号和你在浏览器中输入的地址有关</span></span><br><span class="line">        <span class="comment">// 浏览器里地址格式 协议 + 服务器IP地址 + 端口号 + html文件在服务器的路径</span></span><br><span class="line">        <span class="comment">// 我是本机模拟服务器 浏览器里输入：http://127.0.0.1:8888/day18-code/src/cn/perdant/day18/demo04/web/index.html</span></span><br><span class="line">        <span class="comment">// 我的html文件时存在项目里面的，所以用相对路径即可</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 网页上的图片不是写在html文件里面，而是单独存储在与html同目录（web文件夹）下的，当浏览器读取index.html时，遇到html上有图片，会再去找到图片的存储位置，浏览器会创建一个新线程请求服务器，服务器再写回图片，浏览器读取图片</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">                        <span class="comment">// 浏览器一开始读取到的并不直接是html文件，而是一个包含html文件地址的信息，需要把html文件的地址提取出来，通过字符串的分隔、取子字符串等方法取得html文件的地址</span></span><br><span class="line">                        String line = br.readLine();</span><br><span class="line">                        String[] arr = line.split(<span class="string">" "</span>);</span><br><span class="line">                        String htmlpath = arr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">// 根据html地址创建输入流，从服务器硬盘上读取到服务器内存里，再通过网络输出流写回给浏览器，在写之前，需要在开头先写一些固定格式的字符串。</span></span><br><span class="line">                        FileInputStream fis = <span class="keyword">new</span> FileInputStream(htmlpath);</span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line">                        <span class="comment">// 写入HTTP协议响应头,固定写法，学到现在我还不知道这个具体原理，暂且死记</span></span><br><span class="line">                        os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                        os.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">                        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                        <span class="comment">// 服务器本地流读取html文件的同时，网络流写出给浏览器</span></span><br><span class="line">                        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 释放资源</span></span><br><span class="line">                        fis.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// server.close(); 不需要关闭 让服务器一直处于监听状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述记录于2019.11.26</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">函数式接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-29 20:53:02" itemprop="dateCreated datePublished" datetime="2019-11-29T20:53:02+08:00">2019-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 18:03:40" itemprop="dateModified" datetime="2020-04-10T18:03:40+08:00">2020-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数式接口">函数式接口</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/Stream%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Stream%E6%B5%81/" class="post-title-link" itemprop="url">Stream流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-29 14:05:56" itemprop="dateCreated datePublished" datetime="2019-11-29T14:05:56+08:00">2019-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 18:04:22" itemprop="dateModified" datetime="2020-04-10T18:04:22+08:00">2020-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="stream流">Stream流</h1>
<p>与<code>IO</code>流不同，<code>Stream</code>流是<code>Stream</code>类，它的使用类似工厂的流水线，把一批货物做相同的处理后，继续移动到下一个生产线，做下一步统一处理。<code>Stream</code>可以把一批元素（类似集合）做一个批量处理，例如：过滤、遍历等等。。从而替代了传统的<code>for</code>循环</p>
<p>传统循环方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用传统的方式，遍历集合，对集合中的数据进行过滤</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01List</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个list集合，存储姓名</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"乔斯达"</span>);</span><br><span class="line">        list.add(<span class="string">"阿布德尔"</span>);</span><br><span class="line">        list.add(<span class="string">"波波"</span>);</span><br><span class="line">        list.add(<span class="string">"花太郎"</span>);</span><br><span class="line">        list.add(<span class="string">"花京园"</span>);</span><br><span class="line">        list.add(<span class="string">"花奇"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list集合中的元素进行过滤，只要以花开头的元素，存储到一个新集合中</span></span><br><span class="line">        List&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(<span class="string">"花"</span>))&#123;</span><br><span class="line">                listA.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对listA集合进行过滤，只要姓名长度为3的人，再存储到一个新集合中</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listB = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : listA) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                listB.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历listB集合打印</span></span><br><span class="line">        <span class="keyword">for</span> (String s : listB) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统方式用了3个循环</p>
<p>我们使用<code>Stream</code>流优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用Stream流的方式，遍历集合，对集合中的数据进行过滤</span></span><br><span class="line"><span class="comment">    Stream流是JDK1.8之后出现的</span></span><br><span class="line"><span class="comment">    关注的是做什么，而不是怎么做</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Stream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个list集合，存储姓名</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"乔斯达"</span>);</span><br><span class="line">        list.add(<span class="string">"阿布德尔"</span>);</span><br><span class="line">        list.add(<span class="string">"波波"</span>);</span><br><span class="line">        list.add(<span class="string">"花太郎"</span>);</span><br><span class="line">        list.add(<span class="string">"花京园"</span>);</span><br><span class="line">        list.add(<span class="string">"花奇"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list集合中的元素进行过滤，只要以花开头的元素，存储到一个新集合中</span></span><br><span class="line">        <span class="comment">// 对listA集合进行过滤，只要姓名长度为3的人，再存储到一个新集合中</span></span><br><span class="line">        <span class="comment">// 遍历listB集合打印</span></span><br><span class="line">        list.stream().filter((String name)-&gt;&#123; </span><br><span class="line">            <span class="keyword">return</span> name.startsWith(<span class="string">"花"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">                .filter(name-&gt;name.length() == <span class="number">3</span>)</span><br><span class="line">                .forEach(name-&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取流">获取流</h2>
<p>两种方法：</p>
<ol type="1">
<li>根据<code>Collection</code>获取流方法<code>stream()</code></li>
<li>使用<code>Stream</code>中静态方法<code>of</code>，参数直接传递想要处理的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Stream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把集合转换为Stream流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取键</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line">        <span class="comment">// 获取键值对</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组转换为Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 可变参数可以传递数组</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream7 = Stream.of(arr);</span><br><span class="line">        String[] arr2 = &#123;<span class="string">"a"</span>,<span class="string">"bb"</span>,<span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法">常用方法</h2>
<p>Stream方法分两种</p>
<ul>
<li>终结方法：返回值不是一个流对象，使用之后就不能继续调用流中的其他方法</li>
<li>延迟方法：返回值仍是一个流对象，可以使用链式编程继续调用Stream方法</li>
</ul>
<h3 id="逐一处理-foreach">逐一处理 forEach</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    forEach方法，用来遍历流中的数据</span></span><br><span class="line"><span class="comment">    是一个终结方法，遍历之后就不能继续调用流中的其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Stream_forEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>, <span class="string">"田七"</span>);</span><br><span class="line">        <span class="comment">// 使用流中的方法forEach对流中数据遍历</span></span><br><span class="line">        stream.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤-filter">过滤 filter</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Stream_filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        <span class="comment">// 对流中的元素进行过滤 只要姓张的人</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = stream.filter((String name) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> name.startsWith(<span class="string">"张"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        stream1.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stream流的特点">Stream流的特点</h2>
<p><code>Stream</code>流属于管道流，只能被消费（使用）一次</p>
<p>第一个<code>Stream</code>流调用完毕方法，数据就会流转到下一个<code>Stream</code>流上</p>
<p>而这时第一个<code>Stream</code>流已经使用完毕，就会关闭了</p>
<p>所以第一个<code>Stream</code>流就不能再调用方法了。</p>
<h2 id="映射-map">映射 map</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Stream_map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个String类型的Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>);</span><br><span class="line">        <span class="comment">// 使用map方法，把字符串类型的整数，转换（映射）为Integer类型的整数</span></span><br><span class="line">        Stream stream2 = stream.map((String s) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(i-&gt; System.out.println(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计个数-count">统计个数 count</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    count方法用于统计Stream流中元素的个数</span></span><br><span class="line"><span class="comment">    long count();</span></span><br><span class="line"><span class="comment">    是一个终结方法，返回值是一个整数</span></span><br><span class="line"><span class="comment">    不能再继续调用Stream流中的其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07Stream_count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个Stream流</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream.count();</span><br><span class="line">        System.out.println(count); <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取用前几个-limit">取用前几个 limit</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    limit方法是一个延迟方法，知识对流中的元素进行截取，返回的是一个新的流，所以可以继续调用Stream流中的其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08Stream_limit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个Stream流</span></span><br><span class="line">        String[] arr = &#123;<span class="string">"五六七"</span>,<span class="string">"鸡大宝"</span>,<span class="string">"小飞"</span>,<span class="string">"梅十三"</span>,<span class="string">"可乐"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 使用limit方法对Stream流中的元素进行截取，只要前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.limit(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 遍历stream2</span></span><br><span class="line">        stream2.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳过前几个-skip">跳过前几个 skip</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09Stream_skip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个Stream流</span></span><br><span class="line">        String[] arr = &#123;<span class="string">"五六七"</span>,<span class="string">"鸡大宝"</span>,<span class="string">"小飞"</span>,<span class="string">"梅十三"</span>,<span class="string">"可乐"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 使用skip跳过前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.skip(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 遍历stream2</span></span><br><span class="line">        stream2.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合-concat">组合 concat</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10Stream_concat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"五六七"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        <span class="comment">// 获取一个Stream流</span></span><br><span class="line">        String[] arr = &#123;<span class="string">"五六七"</span>, <span class="string">"鸡大宝"</span>, <span class="string">"小飞"</span>, <span class="string">"梅十三"</span>, <span class="string">"可乐"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 把以上两个流组合为一个流 不会合并相同元素！</span></span><br><span class="line">        Stream&lt;String&gt; concat = Stream.concat(stream1, stream2);</span><br><span class="line">        <span class="comment">// 遍历concat</span></span><br><span class="line">        concat.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<p>集合元素的处理（传统方式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line">        <span class="comment">// 1. 第一支队伍只要名字为3个字的成员姓名，存储到一个新集合中</span></span><br><span class="line">        ArrayList&lt;String&gt; one1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                one1.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 第一个队伍筛选之后只要前3个人，存储到新集合中</span></span><br><span class="line">        ArrayList&lt;String&gt; one2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            one2.add(one1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// 3. 第二个队伍只要姓张的成员姓名，存储到一个新集合中</span></span><br><span class="line">        ArrayList&lt;String&gt; two1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>))&#123;</span><br><span class="line">                two1.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 第二个队伍筛选之后不要前2个人，存储到一个新集合中</span></span><br><span class="line">        ArrayList&lt;String&gt; two2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; two1.size() ; i++) &#123;</span><br><span class="line">            two2.add(two1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将两个队伍合并成一队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        all.addAll(one2);</span><br><span class="line">        all.addAll(two2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 根据姓名创建Person对象</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : all) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Person(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 打印整个队伍Person对象信息</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合元素处理（Stream流方式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.perdant.day19.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line">        <span class="comment">// 1. 第一支队伍只要名字为3个字的成员姓名，存储到一个新集合中 filter</span></span><br><span class="line">        <span class="comment">// 2. 第一个队伍筛选之后只要前3个人，存储到新集合中 limit</span></span><br><span class="line">        Stream&lt;String&gt; oneStream = one.stream().filter(name -&gt; name.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// 3. 第二个队伍只要姓张的成员姓名，存储到一个新集合中 filter</span></span><br><span class="line">        <span class="comment">// 4. 第二个队伍筛选之后不要前2个人，存储到一个新集合中 skip</span></span><br><span class="line">        Stream&lt;String&gt; twoStream = two.stream().filter(name -&gt; name.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将两个队伍合并成一队伍 concat</span></span><br><span class="line">        <span class="comment">// 6. 根据姓名创建Person对象 map</span></span><br><span class="line">        <span class="comment">// 7. 打印整个队伍Person对象信息 forEach</span></span><br><span class="line">        Stream.concat(oneStream,twoStream).map(name-&gt;<span class="keyword">new</span> Person(name)).forEach(p-&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/H%EF%BC%9A%E5%B8%8C%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/H%EF%BC%9A%E5%B8%8C%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">H：希伯特空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-21 09:48:58" itemprop="dateCreated datePublished" datetime="2019-02-21T09:48:58+08:00">2019-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 18:03:50" itemprop="dateModified" datetime="2020-04-10T18:03:50+08:00">2020-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<p>H：希伯特空间</p>
<p>F：H的子集</p>
<p>F成为frame</p>
<p>parseval frame/normalized tight frame</p>
<p>equal norm frame</p>
<p>V：映射/变换 analysis operator <span class="math display">\[
V = 
\begin{bmatrix}
    f_1\\
    f_2\\
    ...\\
    f_n\\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
f_i = 
\begin{bmatrix}
    f_{1i}&amp;f_{2i}&amp;...&amp;f_{ni}
\end{bmatrix}
\quad
x = 
\begin{bmatrix}
    x_1\\
    x_2\\
    ...\\
    x_n\\
\end{bmatrix}
\]</span></p>
<p>当F parseval 时，V等距同构、保距映射（正交矩阵/酉矩阵），且V的伴随矩阵V*是V的左逆矩阵 <span class="math display">\[
(Vx)_i=&lt;x,f_i&gt;\\
\sum|&lt;x,f_i&gt;|^2=\sum|(Vx)_i|^2 = \|x\|^2\\
\|{\begin{bmatrix}
f_1x\\
f_2x\\
...\\
f_nx\\
\end{bmatrix}}\|=
\|{\begin{bmatrix}
x_1\\
x_2\\
...\\
x_n\\
\end{bmatrix}}\|\\
\|Vx\|=\|x\|\\
det(V)=1
\]</span></p>
<p><span class="math display">\[
V^*V = det(V)I=I\\
V^*=V^{-1}=V^T
\]</span></p>
<p>因为V是正交矩阵/酉矩阵，所以<span class="math inline">\(V^{-1}=V^T\)</span>又因为<span class="math inline">\(V^*V=I\)</span></p>
<p>所以每一个frame对应一个矩阵V，V*的列就是向量</p>
<p>F：一个基域</p>
<p>f（n，k）：所有k维的F域n个向量构成的paseval frame的集合</p>
<p><span class="math inline">\(VV^*\)</span>是向量组内积对称矩阵，格拉姆矩阵（Grammian matrix）且是投影矩阵</p>
<p>投影矩阵都是幂等矩阵满足：</p>
<p><font color=red>矩阵的秩等于它的迹</font></p>
<p>F和G两组frame，当且仅当存在酉矩阵U使得<span class="math inline">\(UVV^*U^*=WW^*\)</span>，则<span class="math inline">\(\{f_i\}\quad and\quad \{g_i\}\quad is \quad equivalent\)</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/%E9%A3%9E%E9%A9%B0%E4%BA%BA%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E9%A3%9E%E9%A9%B0%E4%BA%BA%E7%94%9F/" class="post-title-link" itemprop="url">《飞驰人生》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-02-06 06:55:16 / 修改时间：09:42:46" itemprop="dateCreated datePublished" datetime="2019-02-06T06:55:16+08:00">2019-02-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E5%BD%B1%E8%A7%82%E5%90%8E%E6%84%9F/" itemprop="url" rel="index"><span itemprop="name">电影观后感</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure>
<img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzwg624h40j31hc0u0x5f.jpg" alt="" /><figcaption>"小姐，请让一下"</figcaption>
</figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E9%A3%9E%E9%A9%B0%E4%BA%BA%E7%94%9F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/Java-JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java-JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java_JVM内存分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-26 15:41:39" itemprop="dateCreated datePublished" datetime="2018-12-26T15:41:39+08:00">2018-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 18:02:30" itemprop="dateModified" datetime="2020-04-10T18:02:30+08:00">2020-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="jvmjrejdk">JVM、JRE、JDK</h1>
<p><strong>JVM</strong>（Java Virtual Machine）就是一个虚拟的用于执行<strong>字节码</strong>的“虚拟计算机”。包括指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码边解释边运行。</p>
<p>不同操作系统有不同的虚拟机。Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行“。Java虚拟机是实现<strong>跨平台</strong>的核心机制。</p>
<figure>
<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyk7832et4j30u80do0w2.jpg" alt="" /><figcaption>编译解释执行过程</figcaption>
</figure>
<p><strong>JRE</strong>（Java Runtime Environment）包括Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p><strong>JDK</strong>（Java Development Kit）包含了JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<figure>
<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyk7dv9yf8j30gw0cmwg8.jpg" alt="" /><figcaption>JVM JRE JDK 三者的关系</figcaption>
</figure>
<h1 id="jvm内存分析">JVM内存分析</h1>
<p>Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area（实际上方法区也在堆里面）</p>
<p><strong>栈</strong>：</p>
<ul>
<li>栈描述的是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）</li>
<li>JVM为每一个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）</li>
<li><font color=red>栈属于线程私有，不能实现线程间的共享！</font></li>
<li>栈的存储特性<strong>先进后出</strong>（FILO）</li>
<li>栈是由系统自动分配，速度快！栈是一个连续的内存空间！</li>
</ul>
<p><strong>堆</strong>：</p>
<ul>
<li>堆用于存储创建好的对象和<strong>数组</strong>（数组也是对象）</li>
<li>JVM只有一个堆，被所有线程共享</li>
<li>堆事一个不连续的内存空间，分配灵活，速度慢！</li>
</ul>
<p><strong>方法区</strong>（又叫静态区）：</p>
<ul>
<li>JVM只有一个方法区，被所有线程共享！</li>
<li>方法区实际也是堆，只是用于存储类、常量相关的信息！</li>
<li>用来存放程序中永远不变或唯一的内容。（类信息、Class对象、<font color=red>静态变量、字符串常量</font>等）</li>
</ul>
<h1 id="example">Example</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.com.guan.javajicu; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123; </span><br><span class="line">  String str = <span class="keyword">new</span> String(<span class="string">"good"</span>); </span><br><span class="line">  <span class="keyword">char</span>[] ch = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     Example ex = <span class="keyword">new</span> Example(); </span><br><span class="line">     ex.change(ex.str, ex.ch); </span><br><span class="line">     System.out.print(ex.str +<span class="string">"and"</span>); </span><br><span class="line">     System.out.print(ex.ch);  </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span></span>&#123; </span><br><span class="line">     str= <span class="string">"test ok"</span>; </span><br><span class="line">     ch[<span class="number">0</span>]= <span class="string">'g'</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述程序的输出结果为？</p>
</blockquote>
<p>画出内存图，所有问题一目了然：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyk8xnf9upj30oo0ht0ty.jpg" /></p>
<p>由上图可以看出，String类是不可变的，赋予新的字符串时，是在方法区中开辟了新字符串的存储空间，所以局部变量str的指针由绿色的线改为红色，ch指向的数组中的第一个元素由a变为g，所以只是局部变量发生变化，类的成员变量没变。</p>
<blockquote>
<p>答案：goodandgbc</p>
</blockquote>
<h1 id="jvm类加载过程分析">JVM类加载过程分析</h1>
<p>加载-&gt;链接-&gt;初始化</p>
<ul>
<li>加载：
<ul>
<li>将class字节码加载到内存中，并将这些静态数据转换成方法区中的运行时的数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</li>
</ul></li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程
<ul>
<li>验证：
<ul>
<li>确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
</ul></li>
<li>准备：
<ul>
<li>正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配</li>
</ul></li>
<li>解析：
<ul>
<li>虚拟机常量池内的符号引用替换为直接饮用的过程</li>
</ul></li>
<li>初始化：
<ul>
<li>初始化阶段是执行类构造器<clinit>()方法的过程。该过程是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>类加载初始化只有一次，并不需要反复加载。
<ul>
<li>类的主动引用初始化（一定会发生类的初始化）
<ul>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当虚拟机启动，java Hello，则一定会初始化Hello类，说白了就是先启动main方法所在的类</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</li>
</ul></li>
<li>类的被动引用（不会发生类的初始化）
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化
<ul>
<li>通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul></li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.aqiang.leijiazai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(A.width);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> width = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化类A"</span>);</span><br><span class="line">        width = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建A类的对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：</p>
<p>静态初始化类A 创建A类的对象 300</p>
</blockquote>
<p><strong>分析</strong></p>
<ul>
<li>从main方法开始，下面new了一个A，先进行<font color=red>类加载</font>，把11行到15行的赋值动作以及静态块合并（从上而下进行合并，所以打印300而不是100）到一个类初始化方法里<font color=red>（初始化阶段）</font>，初始化完后才能真正的开始new方法，调用16行的构造函数。</li>
<li>JVM中的具体流程：方法区中加载数据结构--&gt;堆中构建java.lang.Class类—&gt;栈中压入方法栈帧—&gt;堆中生成对应的new的对象—&gt;将堆中的对象赋值给栈中方法的成员变量</li>
</ul>
<figure>
<img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzc0lxiypjj31b40sedqg.jpg" alt="" /><figcaption>加载链接初始化过程图</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/Hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo搭建属于自己的博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-02 20:33:33" itemprop="dateCreated datePublished" datetime="2018-11-02T20:33:33+08:00">2018-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-01 22:05:04" itemprop="dateModified" datetime="2019-02-01T22:05:04+08:00">2019-02-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bolg%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">bolg搭建</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwwelmjg3pj317y0u0aos.jpg" width="50%" height="50%"></p>
<blockquote>
<p>封面是我的灵魂绘图</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/Machine-Learing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Machine-Learing/" class="post-title-link" itemprop="url">Machine Learing 课程笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-11-02 16:59:00 / 修改时间：17:07:26" itemprop="dateCreated datePublished" datetime="2018-11-02T16:59:00+08:00">2018-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="machine-learning-概览">machine learning 概览</h1>
<p>machine learning是一个很大的理论体系，目前分为下面几类： <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwttwjk4ovj31kw0ijdic.jpg" alt="learning map" /></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Machine-Learing/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/Solution-to-the-Paulsen-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Solution-to-the-Paulsen-problem/" class="post-title-link" itemprop="url">Solution to the Paulsen problem(via operator scaling)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-26 21:51:00" itemprop="dateCreated datePublished" datetime="2018-10-26T21:51:00+08:00">2018-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 16:58:54" itemprop="dateModified" datetime="2020-04-10T16:58:54+08:00">2020-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">文献阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今年STOC上的一篇会议论文 ，这是参照作者Lap Chi Lau在IAS上演讲所做的记录。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Solution-to-the-Paulsen-problem/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.yoursite.com/My-First-Test-Blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一清">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Poet">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/My-First-Test-Blog/" class="post-title-link" itemprop="url">My First Test Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-25 13:05:58" itemprop="dateCreated datePublished" datetime="2018-10-25T13:05:58+08:00">2018-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-02 17:06:06" itemprop="dateModified" datetime="2018-11-02T17:06:06+08:00">2018-11-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">blog搭建</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="test">TEST</h1>
<p>这是我建的blog的第一篇文章，主要用来测试markdown</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/My-First-Test-Blog/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="一清"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">一清</p>
  <div class="site-description" itemprop="description">花有重开日，人无再少年</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/NaivePerdant" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NaivePerdant" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1016259419@qq.com" title="E-Mail → mailto:1016259419@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">一清</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
